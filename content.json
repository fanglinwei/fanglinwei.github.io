{"meta":{"title":"calm's Blog","subtitle":"闲散杂货铺","description":"一个有趣的博客","author":"calm","url":"http://www.calm1993.com"},"pages":[{"title":"分类","date":"2017-08-02T10:06:23.000Z","updated":"2017-08-02T10:09:52.000Z","comments":false,"path":"categories/index.html","permalink":"http://www.calm1993.com/categories/index.html","excerpt":"","text":""},{"title":"关于","date":"2017-08-02T09:23:51.000Z","updated":"2019-07-10T08:47:26.000Z","comments":true,"path":"about/index.html","permalink":"http://www.calm1993.com/about/index.html","excerpt":"","text":"最怕一生碌碌无为 还安慰自己平凡可贵"},{"title":"标签","date":"2017-08-02T10:06:58.000Z","updated":"2017-08-02T10:10:32.000Z","comments":false,"path":"tags/index.html","permalink":"http://www.calm1993.com/tags/index.html","excerpt":"","text":""}],"posts":[{"title":"全局安装软件包时解决EACCES权限错误","slug":"Hexo/全局安装软件包时解决EACCES权限错误","date":"2019-08-22T03:10:13.000Z","updated":"2019-08-22T03:12:13.937Z","comments":true,"path":"post/Hexo/全局安装软件包时解决EACCES权限错误.html","link":"","permalink":"http://www.calm1993.com/post/Hexo/全局安装软件包时解决EACCES权限错误.html","excerpt":"","text":"如果EACCES在尝试全局安装软件包时看到错误，则可以： 使用节点版本管理器重新安装npm（推荐）， 或者 手动更改npm的默认目录 重新安装NPM与节点版本管理 这是避免权限问题的最佳方法。要使用节点版本管理器重新安装npm，请按照“ 下载并安装Node.js和npm ”中的步骤操作。在安装节点版本管理器之前，您无需删除当前版本的npm或Node.js. 手动更改npm的默认目录 注意：本节不适用于Microsoft Windows。 要最小化权限错误的可能性，可以将npm配置为使用其他目录。在此示例中，您将在主目录中创建并使用隐藏目录。 备份您的计算机。 在命令行的主目录中，为全局安装创建一个目录： $ mkdir ~/.npm-global 配置npm以使用新的目录路径： $ npm config set prefix '~/.npm-global' 在首选的文本编辑器中，打开或创建一个~/.profile文件并添加以下行： export PATH=~/.npm-global/bin:$PATH 在命令行上，更新系统变量： $ source ~/.profile 要测试新配置，请在不使用sudo以下情况下全局安装软件包： $ npm install -g jshint 您可以使用相应的ENV变量（例如，如果您不想修改~/.profile），而不是步骤2-4 ： NPM_CONFIG_PREFIX=~/.npm-global 如果使用的是npm 5.2或更高版本，则可能需要将npx视为运行全局命令的替代方法，尤其是在偶尔需要命令的情况下。有关更多信息，请参阅有关npx的这篇文章。","categories":[{"name":"Hexo","slug":"Hexo","permalink":"http://www.calm1993.com/categories/Hexo/"}],"tags":[{"name":"Hexo","slug":"Hexo","permalink":"http://www.calm1993.com/tags/Hexo/"}]},{"title":"利用shell脚本快速上传bugly的符号表","slug":"iOS/利用shell脚本快速上传bugly的符号表","date":"2018-09-27T07:10:59.000Z","updated":"2018-09-27T08:34:12.000Z","comments":true,"path":"post/iOS/利用shell脚本快速上传bugly的符号表.html","link":"","permalink":"http://www.calm1993.com/post/iOS/利用shell脚本快速上传bugly的符号表.html","excerpt":"开发中，为了更好的用户体验或者为了bug跟踪，可能会需要使用腾讯的bugly分析工具.但是要使用bugly分析报错需要从dYSM中取出符号表配置上传.","text":"开发中，为了更好的用户体验或者为了bug跟踪，可能会需要使用腾讯的bugly分析工具.但是要使用bugly分析报错需要从dYSM中取出符号表配置上传. 符号表说明: Bugly iOS 符号表配置按照bugly官网配置java环境准备dSYM文件dSYM文件是指具有调试信息的目标文件，文件名通常为：xxx.app.dSYM Bugly iOS 符号表配置有说明通过xcode获取或者通过iTunes Connect获取 下载buglySymboliOS.jar下载最新版Bugly iOS符号表工具.里面有一个buglySymboliOS.jar文件,然后把该文件和之前下载的dYSM文件放在同一个文件夹里 准备脚本创建一个buglydSYMTool.sh的脚本文件, 将下面代码拷贝到脚本文件中然后终端命令执行$ bash buglydSYMTool.sh 脚本代码function printIndroduction &#123; echo \"Bugly符号表上传工具IOS版 -- dSYM Tool for IOS\" echo \"适用平台 -- Applicable platform: Linux\" echo \"Copyright 2018 calm. All rights reserved.\" echo \"\"&#125;function uploadDsym &#123; files=`find . -name \"*.dSYM\"` for fileName in $files; do echo \"fileName $fileName\" # Appid be6f31d4b5 # Appkey 2ffe6156-8b9a-4d2e-81cc-a2c34f894567 # package com.chongdingdahui.app # version(build) 2.2.0(0.4.9) # java -jar buglySymboliOS.jar -i \"$fileName\" -u -id \"$appid\" -key \"$appkey\" -package \"$bundleId\" -version \"$version\" done&#125;# mainprintIndroduction输入app 信息echo -n \"enter the App id: \"read appid echo -n \"enter the App key: \"read appkey echo -n \"enter the App bundleId: \"read bundleId echo -n \"enter the App version: \"read versionecho -n \"enter the dsymPath: \"read pathcd \"$path\"# Check the Java EnvironmentCheckJavaVersion=$(java -version 2&gt;&amp;1)echo \"$CheckJavaVersion\" | grep -q \"Java(TM)\"if [ $? -ne 0 ]then echo \"----\" echo \"系统中未安装Java或者未配置Java环境，请检查！-- Please check if your system has installed Java or configured environment for Java!\" echo \"Java官网 -- Java Web Site：www.java.com\" exit 1fi# Check the jar#ShellDir=$(cd `dirname $0`; pwd)pathName=$(cd `dirname $0`; pwd)JarName=\"buglySymboliOS.jar\"JarPath=\"$pathName/$JarName\"if [ ! -f \"$JarPath\" ]; then echo \"----\" echo \"未找到\\\"$JarName\\\"！-- Can not find \\\"$JarName\\\"!\" echo \"请将\\\"$JarName\\\"复制到\\\"$pathName\\\"中！\" echo \" -- Please copy \\\"$JarName\\\" to \\\"$pathName\\\"!\" exit 2fi # call the function to extract uploaduploadDsym $* 该脚本已上传Github直接下载, 只是一个小工具,不喜勿喷.欢迎star","categories":[],"tags":[{"name":"iOS","slug":"iOS","permalink":"http://www.calm1993.com/tags/iOS/"}]},{"title":"swift学习---优雅的iPhone全尺寸屏幕精准适配工具","slug":"Swift/swift学习---优雅的iPhone全尺寸屏幕精准适配工具","date":"2018-05-24T05:43:59.000Z","updated":"2018-07-19T06:58:00.000Z","comments":true,"path":"post/Swift/swift学习---优雅的iPhone全尺寸屏幕精准适配工具.html","link":"","permalink":"http://www.calm1993.com/post/Swift/swift学习---优雅的iPhone全尺寸屏幕精准适配工具.html","excerpt":"原文:Inch - 优雅的iPhone全尺寸屏幕精准适配工具 前言很多时候我们苦于需要精准的适配各个屏幕尺寸的UI, 通常根据某一种倍数计算的结果并不能满足精准的需求, 随着iPhone设备不同尺寸的增加 这种需求更加迫切, 当然我说的这些都是属于对于产品细节要求苛刻 追求完美的那一部分, 如果你觉得随便适配适配看着还行就够了, 那么现在就可以X掉这个页面了.","text":"原文:Inch - 优雅的iPhone全尺寸屏幕精准适配工具 前言很多时候我们苦于需要精准的适配各个屏幕尺寸的UI, 通常根据某一种倍数计算的结果并不能满足精准的需求, 随着iPhone设备不同尺寸的增加 这种需求更加迫切, 当然我说的这些都是属于对于产品细节要求苛刻 追求完美的那一部分, 如果你觉得随便适配适配看着还行就够了, 那么现在就可以X掉这个页面了. 问题很多时候为了解决这一情况的问题 OC中我们通常会写一些宏 例如 ISIPHONEX ISPLUS… 之类的提供快速判断的 但是每一个地方都需要写如此多的判断显然不是明智的, 也有AUTO(20,25,30) 类似这种的宏函数, 但是他们都有一个共同的缺点 扩展性不好, 假如每年果爹都出一块新尺寸的设备.. 使用这种思路适配简直是鼓励跳槽或者是闲来无事打发时间. 解决方案考虑到扩展性和每一个尺寸的精确性, 我建了一个类型枚举 并且声明了iPhone所有尺寸类型 命名方式以 i开头+英寸数字: enum InchType &#123; case unknown case i58Full case i55 case i47 case i40 case i35 .... 接下来就是确定当前设备属于哪个类型 同样在类型枚举中增加一个当前类型的常量 通过闭包的方式初始化这个常量.未来如果增加了新的设备 我们直接扩展这个枚举即可. enum InchType &#123; case unknown case i58Full case i55 case i47 case i40 case i35 static let current: InchType = &#123; let screenWidth = Float(UIScreen.main.bounds.width) let screenHeight = Float(UIScreen.main.bounds.height) let width = min(screenWidth, screenHeight) let height = max(screenWidth, screenHeight) if width == 375, height == 812 &#123; return .i58Full &#125; if width == 414, height == 736 &#123; return .i55 &#125; if width == 375, height == 667 &#123; return .i47 &#125; if width == 320, height == 568 &#123; return .i40 &#125; if width == 320, height == 480 &#123; return .i35 &#125; return .unknown &#125; ()&#125; 现在当前设备类型已经得到, 接下来就是考虑如何设计才能保证更灵活的扩展以及调用, 思前想后这种情景中最合适的莫过于链式, 同时想达到最大的灵活性 在Swift中必然要用到强大的protocol, 这样设计的好处在于链式可以无限制扩展新的值 并且语法优雅 调用起来简洁美观, protocol可以把应用对象不仅仅局限在一种类型上. protocol Inchable &#123; func i58full(_ value: Self) -&gt; Self func i55(_ value: Self) -&gt; Self func i47(_ value: Self) -&gt; Self func i40(_ value: Self) -&gt; Self func i35(_ value: Self) -&gt; Self&#125; 为协议扩展默认实现 根据当前类型判断返回原有的还是该类型的. extension Inchable &#123; func i58full(_ value: Self) -&gt; Self &#123; return InchType.current == .i58Full ? value : self &#125; func i55(_ value: Self) -&gt; Self &#123; return InchType.current == .i55 ? value : self &#125; func i47(_ value: Self) -&gt; Self &#123; return InchType.current == .i47 ? value : self &#125; func i40(_ value: Self) -&gt; Self &#123; return InchType.current == .i40 ? value : self &#125; func i35(_ value: Self) -&gt; Self &#123; return InchType.current == .i35 ? value : self &#125;&#125; 最后就可以让我们需要支持的类型实现该协议 extension Int: Inchable &#123;&#125;extension Float: Inchable &#123;&#125;extension CGFloat: Inchable &#123;&#125;extension Double: Inchable &#123;&#125;extension String: Inchable &#123;&#125; 到这里基本上就已经写完了, 下面看一下调用效果: view.height = 10.i35(4).i40(5).i47(7).i55(9).i58full(20) OK, 是不是感觉很清爽? 再啰嗦一下, 以上面的示例来说明一下干了些啥, 为某个view设置一下高度, 默认是10 那么如果是3.5英寸屏幕(4s)返回值就会是4, 如果是4.0英寸(se/5s)返回值就是5, 以此类推.. 5.8英寸full就是iPhone X. 当然如果有些尺寸不需要适配你也可以不写, 如果当前设备你没有设置就会返回默认值 (示例中为 10), 这样一来即使未来增加了某些新的尺寸设备, 我们还没来得及更新适配, 因为有默认值所以问题也不大, 在扩展新尺寸时只需要在枚举中增加新类型并且在需要适配的地方后面追加一个.iXX()即可. 各种玩法, 甚至可以扩展UIColor实现该协议 不同设备不同颜色也是阔以玩的, 当然除了适配屏幕外 还可以用这个思路完成其他的操作 留给你们点想象空间. /// Stringlabel.text = \"真实姓名:\".i47(\"您的真实姓名\").i55(\"请输入您的真实姓名\").i58full(\"输入真实姓名\") 扩充如果需要不同宽屏下按比例适配屏幕我们可以扩充一下协议protocol InchAutoable &#123; /// 自动处理 /// /// - Parameter handle: 处理闭包 /// - Returns: 返回值 func auto(handle: (Self)-&gt; Self) -&gt;Self&#125; 我们需要支持的类型实现该协议extension Int: InchAutoable &#123;&#125;extension Float: InchAutoable &#123;&#125;extension CGFloat: InchAutoable &#123;&#125;extension Double: InchAutoable &#123;&#125;extension InchAutoable &#123; func auto(handle: (Self)-&gt; Self) -&gt; Self &#123; return handle(self) &#125;&#125;extension InchAutoable where Self: BinaryFloatingPoint &#123; /// 自动比例转换 (基于屏幕宽度) /// /// - Parameter baseWidth: 基准屏幕宽度 默认375 /// - Returns: 返回结果 func auto(_ baseWidth: Double = 375.0) -&gt; Self &#123; let screenWidth = Double(UIScreen.main.bounds.width) let screenHeight = Double(UIScreen.main.bounds.height) let width = min(screenWidth, screenHeight) return auto(handle: &#123; $0 * Self(width / baseWidth) &#125;) &#125;&#125; 扩充一下CGFloat的转换 public extension IntegerLiteralType &#123; public var f: CGFloat &#123; return CGFloat(self) &#125;&#125;public extension FloatLiteralType &#123; public var f: CGFloat &#123; return CGFloat(self) &#125;&#125;public extension Float32 &#123; public var f: CGFloat &#123; return CGFloat(self) &#125;&#125; 使用let viewW: CGFloat = 500.auto().f 总结以上方案可以很好地支持不同设备精准适配的需求, 并且保持良好的扩展性和灵活性, 这里也充分利用了Swift强大的语法特性, 为适配创造了更多的可能. 代码:GitHub 如果觉得好用就请给作者star","categories":[],"tags":[{"name":"Swift","slug":"Swift","permalink":"http://www.calm1993.com/tags/Swift/"}]},{"title":"隐藏系统导航栏手势失效解决方案","slug":"iOS/隐藏系统导航栏手势失效解决方案","date":"2018-05-24T04:43:59.000Z","updated":"2018-05-24T05:01:26.000Z","comments":true,"path":"post/iOS/隐藏系统导航栏手势失效解决方案.html","link":"","permalink":"http://www.calm1993.com/post/iOS/隐藏系统导航栏手势失效解决方案.html","excerpt":"在iOS开发中通常会做的隐藏状态栏或者自定义返回按钮,相应的pop手势也失效了，下面就需要解决下这个问题。","text":"在iOS开发中通常会做的隐藏状态栏或者自定义返回按钮,相应的pop手势也失效了，下面就需要解决下这个问题。 navigationBar.isHidden = true self.navigationItem.leftBarButtonItem = 自定义返回按钮; 解决方案:我们在自定义导航控制器里我们自己的手势 class NavigationController: UINavigationController &#123; override func viewDidLoad() &#123; super.viewDidLoad() navigationBar.isHidden = true setupEdgeGesture() &#125; func setupEdgeGesture() &#123; guard let targets = interactivePopGestureRecognizer!.value(forKey: \"_targets\") as? [NSObject] else &#123; return &#125; let targetObjc = targets[0] let target = targetObjc.value(forKey: \"target\") let action = Selector((\"handleNavigationTransition:\")) //UIPanGestureRecognizer 全屏手势 //UIScreenEdgePanGestureRecognizer 边缘手势 let panGes = UIScreenEdgePanGestureRecognizer(target: target, action: action) panGes.delegate = self; view.addGestureRecognizer(panGes) &#125;&#125;//如果需要监听手势extension NavigationController: UIGestureRecognizerDelegate &#123; func gestureRecognizerShouldBegin(_ gestureRecognizer: UIGestureRecognizer) -&gt; Bool &#123; if let transitioning = value(forKey: \"_isTransitioning\") as? Bool &#123; if transitioning &#123;return false&#125; &#125; return viewControllers.count &gt; 1 &#125; &#125; 这样就可以有效的解决返回pop手势失效问题 各位看官如果发现有什么不对的，请留言或者加qq：286349583，一起讨论，谢谢！！","categories":[],"tags":[{"name":"iOS","slug":"iOS","permalink":"http://www.calm1993.com/tags/iOS/"}]},{"title":"iOS获取手机设备型号","slug":"iOS/iOS获取手机型号","date":"2018-05-24T04:43:59.000Z","updated":"2018-09-27T02:15:26.000Z","comments":true,"path":"post/iOS/iOS获取手机型号.html","link":"","permalink":"http://www.calm1993.com/post/iOS/iOS获取手机型号.html","excerpt":"·开发中，为了更好的用户体验或者为了bug跟踪，可能会需要获取用户的应用信息、系统信息、设备信息。这些信息的获取可以根据不同的设备或者App、系统版本来提供不同的功能或更好的用户体验，或者让开发者能更好的分析用户的问题原因。","text":"·开发中，为了更好的用户体验或者为了bug跟踪，可能会需要获取用户的应用信息、系统信息、设备信息。这些信息的获取可以根据不同的设备或者App、系统版本来提供不同的功能或更好的用户体验，或者让开发者能更好的分析用户的问题原因。 iOS获取具体的设备型号OC代码获取iOS设备型号： // 需要#import &lt;sys/utsname.h&gt;+ (NSString*)deviceModelName&#123; struct utsname systemInfo; uname(&amp;systemInfo); NSString *deviceModel = [NSString stringWithCString:systemInfo.machine encoding:NSUTF8StringEncoding]; if ([deviceModel isEqualToString:@\"iPhone3,1\"]) return @\"iPhone 4\"; if ([deviceModel isEqualToString:@\"iPhone3,2\"]) return @\"iPhone 4\"; if ([deviceModel isEqualToString:@\"iPhone3,3\"]) return @\"iPhone 4\"; if ([deviceModel isEqualToString:@\"iPhone4,1\"]) return @\"iPhone 4S\"; if ([deviceModel isEqualToString:@\"iPhone5,1\"]) return @\"iPhone 5\"; if ([deviceModel isEqualToString:@\"iPhone5,2\"]) return @\"iPhone 5 (GSM+CDMA)\"; if ([deviceModel isEqualToString:@\"iPhone5,3\"]) return @\"iPhone 5c (GSM)\"; if ([deviceModel isEqualToString:@\"iPhone5,4\"]) return @\"iPhone 5c (GSM+CDMA)\"; if ([deviceModel isEqualToString:@\"iPhone6,1\"]) return @\"iPhone 5s (GSM)\"; if ([deviceModel isEqualToString:@\"iPhone6,2\"]) return @\"iPhone 5s (GSM+CDMA)\"; if ([deviceModel isEqualToString:@\"iPhone7,1\"]) return @\"iPhone 6 Plus\"; if ([deviceModel isEqualToString:@\"iPhone7,2\"]) return @\"iPhone 6\"; if ([deviceModel isEqualToString:@\"iPhone8,1\"]) return @\"iPhone 6s\"; if ([deviceModel isEqualToString:@\"iPhone8,2\"]) return @\"iPhone 6s Plus\"; if ([deviceModel isEqualToString:@\"iPhone8,4\"]) return @\"iPhone SE\";// 日行两款手机型号均为日本独占，可能使用索尼FeliCa支付方案而不是苹果支付 if ([deviceModel isEqualToString:@\"iPhone9,1\"]) return @\"国行、日版、港行iPhone 7\"; if ([deviceModel isEqualToString:@\"iPhone9,2\"]) return @\"港行、国行iPhone 7 Plus\"; if ([deviceModel isEqualToString:@\"iPhone9,3\"]) return @\"美版、台版iPhone 7\"; if ([deviceModel isEqualToString:@\"iPhone9,4\"]) return @\"美版、台版iPhone 7 Plus\"; if ([deviceModel isEqualToString:@\"iPhone10,1\"]) return @\"iPhone_8\"; if ([deviceModel isEqualToString:@\"iPhone10,4\"]) return @\"iPhone_8\"; if ([deviceModel isEqualToString:@\"iPhone10,2\"]) return @\"iPhone_8_Plus\"; if ([deviceModel isEqualToString:@\"iPhone10,5\"]) return @\"iPhone_8_Plus\"; if ([deviceModel isEqualToString:@\"iPhone10,3\"]) return @\"iPhone_X\"; if ([deviceModel isEqualToString:@\"iPhone10,6\"]) return @\"iPhone_X\"; if ([deviceModel isEqualToString:@\"iPod1,1\"]) return @\"iPod Touch 1G\"; if ([deviceModel isEqualToString:@\"iPod2,1\"]) return @\"iPod Touch 2G\"; if ([deviceModel isEqualToString:@\"iPod3,1\"]) return @\"iPod Touch 3G\"; if ([deviceModel isEqualToString:@\"iPod4,1\"]) return @\"iPod Touch 4G\"; if ([deviceModel isEqualToString:@\"iPod5,1\"]) return @\"iPod Touch (5 Gen)\"; if ([deviceModel isEqualToString:@\"iPad1,1\"]) return @\"iPad\"; if ([deviceModel isEqualToString:@\"iPad1,2\"]) return @\"iPad 3G\"; if ([deviceModel isEqualToString:@\"iPad2,1\"]) return @\"iPad 2 (WiFi)\"; if ([deviceModel isEqualToString:@\"iPad2,2\"]) return @\"iPad 2\"; if ([deviceModel isEqualToString:@\"iPad2,3\"]) return @\"iPad 2 (CDMA)\"; if ([deviceModel isEqualToString:@\"iPad2,4\"]) return @\"iPad 2\"; if ([deviceModel isEqualToString:@\"iPad2,5\"]) return @\"iPad Mini (WiFi)\"; if ([deviceModel isEqualToString:@\"iPad2,6\"]) return @\"iPad Mini\"; if ([deviceModel isEqualToString:@\"iPad2,7\"]) return @\"iPad Mini (GSM+CDMA)\"; if ([deviceModel isEqualToString:@\"iPad3,1\"]) return @\"iPad 3 (WiFi)\"; if ([deviceModel isEqualToString:@\"iPad3,2\"]) return @\"iPad 3 (GSM+CDMA)\"; if ([deviceModel isEqualToString:@\"iPad3,3\"]) return @\"iPad 3\"; if ([deviceModel isEqualToString:@\"iPad3,4\"]) return @\"iPad 4 (WiFi)\"; if ([deviceModel isEqualToString:@\"iPad3,5\"]) return @\"iPad 4\"; if ([deviceModel isEqualToString:@\"iPad3,6\"]) return @\"iPad 4 (GSM+CDMA)\"; if ([deviceModel isEqualToString:@\"iPad4,1\"]) return @\"iPad Air (WiFi)\"; if ([deviceModel isEqualToString:@\"iPad4,2\"]) return @\"iPad Air (Cellular)\"; if ([deviceModel isEqualToString:@\"iPad4,4\"]) return @\"iPad Mini 2 (WiFi)\"; if ([deviceModel isEqualToString:@\"iPad4,5\"]) return @\"iPad Mini 2 (Cellular)\"; if ([deviceModel isEqualToString:@\"iPad4,6\"]) return @\"iPad Mini 2\"; if ([deviceModel isEqualToString:@\"iPad4,7\"]) return @\"iPad Mini 3\"; if ([deviceModel isEqualToString:@\"iPad4,8\"]) return @\"iPad Mini 3\"; if ([deviceModel isEqualToString:@\"iPad4,9\"]) return @\"iPad Mini 3\"; if ([deviceModel isEqualToString:@\"iPad5,1\"]) return @\"iPad Mini 4 (WiFi)\"; if ([deviceModel isEqualToString:@\"iPad5,2\"]) return @\"iPad Mini 4 (LTE)\"; if ([deviceModel isEqualToString:@\"iPad5,3\"]) return @\"iPad Air 2\"; if ([deviceModel isEqualToString:@\"iPad5,4\"]) return @\"iPad Air 2\"; if ([deviceModel isEqualToString:@\"iPad6,3\"]) return @\"iPad Pro 9.7\"; if ([deviceModel isEqualToString:@\"iPad6,4\"]) return @\"iPad Pro 9.7\"; if ([deviceModel isEqualToString:@\"iPad6,7\"]) return @\"iPad Pro 12.9\"; if ([deviceModel isEqualToString:@\"iPad6,8\"]) return @\"iPad Pro 12.9\"; if ([deviceModel isEqualToString:@\"AppleTV2,1\"]) return @\"Apple TV 2\"; if ([deviceModel isEqualToString:@\"AppleTV3,1\"]) return @\"Apple TV 3\"; if ([deviceModel isEqualToString:@\"AppleTV3,2\"]) return @\"Apple TV 3\"; if ([deviceModel isEqualToString:@\"AppleTV5,3\"]) return @\"Apple TV 4\"; if ([deviceModel isEqualToString:@\"i386\"]) return @\"Simulator\"; if ([deviceModel isEqualToString:@\"x86_64\"]) return @\"Simulator\"; return deviceModel; &#125; 记得一定要 #import &lt;sys/utsname.h&gt;啊，到时候没有导入编译不通过了不要找我啊。 Swift代码获取iOS设备型号：extension UIDevice &#123; var phoneName: String &#123; var systemInfo = utsname() uname(&amp;systemInfo) let machineMirror = Mirror(reflecting: systemInfo.machine) let identifier = machineMirror.children.reduce(\"\") &#123; identifier, element in guard let value = element.value as? Int8, value != 0 else &#123; return identifier &#125; return identifier + String(UnicodeScalar(UInt8(value))) &#125; switch identifier &#123; case \"iPod1,1\": return \"iPod Touch 1\" case \"iPod2,1\": return \"iPod Touch 2\" case \"iPod3,1\": return \"iPod Touch 3\" case \"iPod4,1\": return \"iPod Touch 4\" case \"iPod5,1\": return \"iPod Touch (5 Gen)\" case \"iPod7,1\": return \"iPod Touch 6\" case \"iPhone3,1\", \"iPhone3,2\", \"iPhone3,3\": return \"iPhone 4\" case \"iPhone4,1\": return \"iPhone 4s\" case \"iPhone5,1\": return \"iPhone 5\" case \"iPhone5,2\": return \"iPhone 5 (GSM+CDMA)\" case \"iPhone5,3\": return \"iPhone 5c (GSM)\" case \"iPhone5,4\": return \"iPhone 5c (GSM+CDMA)\" case \"iPhone6,1\": return \"iPhone 5s (GSM)\" case \"iPhone6,2\": return \"iPhone 5s (GSM+CDMA)\" case \"iPhone7,2\": return \"iPhone 6\" case \"iPhone7,1\": return \"iPhone 6 Plus\" case \"iPhone8,1\": return \"iPhone 6s\" case \"iPhone8,2\": return \"iPhone 6s Plus\" case \"iPhone8,4\": return \"iPhone SE\" case \"iPhone9,1\": return \"国行、日版、港行iPhone 7\" case \"iPhone9,2\": return \"港行、国行iPhone 7 Plus\" case \"iPhone9,3\": return \"美版、台版iPhone 7\" case \"iPhone9,4\": return \"美版、台版iPhone 7 Plus\" case \"iPhone10,1\",\"iPhone10,4\": return \"iPhone 8\" case \"iPhone10,2\",\"iPhone10,5\": return \"iPhone 8 Plus\" case \"iPhone10,3\",\"iPhone10,6\": return \"iPhone X\" case \"iPad1,1\": return \"iPad\" case \"iPad1,2\": return \"iPad 3G\" case \"iPad2,1\", \"iPad2,2\", \"iPad2,3\", \"iPad2,4\": return \"iPad 2\" case \"iPad2,5\", \"iPad2,6\", \"iPad2,7\": return \"iPad Mini\" case \"iPad3,1\", \"iPad3,2\", \"iPad3,3\": return \"iPad 3\" case \"iPad3,4\", \"iPad3,5\", \"iPad3,6\": return \"iPad 4\" case \"iPad4,1\", \"iPad4,2\", \"iPad4,3\": return \"iPad Air\" case \"iPad4,4\", \"iPad4,5\", \"iPad4,6\": return \"iPad Mini 2\" case \"iPad4,7\", \"iPad4,8\", \"iPad4,9\": return \"iPad Mini 3\" case \"iPad5,1\", \"iPad5,2\": return \"iPad Mini 4\" case \"iPad5,3\", \"iPad5,4\": return \"iPad Air 2\" case \"iPad6,3\", \"iPad6,4\": return \"iPad Pro 9.7\" case \"iPad6,7\", \"iPad6,8\": return \"iPad Pro 12.9\" case \"AppleTV2,1\": return \"Apple TV 2\" case \"AppleTV3,1\",\"AppleTV3,2\": return \"Apple TV 3\" case \"AppleTV5,3\": return \"Apple TV 4\" case \"i386\", \"x86_64\": return \"Simulator\" default: return identifier &#125; &#125;&#125;","categories":[],"tags":[{"name":"iOS","slug":"iOS","permalink":"http://www.calm1993.com/tags/iOS/"}]},{"title":"swift学习---利用protocol加载Nib","slug":"Swift/swift学习---利用protocol加载Nib","date":"2018-05-18T03:06:59.000Z","updated":"2019-08-02T08:41:38.000Z","comments":true,"path":"post/Swift/swift学习---利用protocol加载Nib.html","link":"","permalink":"http://www.calm1993.com/post/Swift/swift学习---利用protocol加载Nib.html","excerpt":"写一个加载NibLoadable的协议,然后拓展到UIViewController和UIView中","text":"写一个加载NibLoadable的协议,然后拓展到UIViewController和UIView中 protocol NibLoadable &#123;&#125;extension NibLoadable where Self : UIView &#123; static func loadFromNib(_ name : String? = nil) -&gt; Self &#123; let loadName = name == nil ? \"\\(self)\" : name! return Bundle.main.loadNibNamed(loadName, owner: nil, options: nil)?.first as! Self &#125;&#125;extension NibLoadable where Self : UIViewController &#123; static func loadFromStoryboard(_ name: String? = nil, withIdentifier: String? = nil) -&gt; Self &#123; let loadName = name == nil ? \"\\(self)\" : name! guard let sbId = identifier else &#123; return UIStoryboard(name: loadName, bundle: nil).instantiateInitialViewController() as! Self &#125; return UIStoryboard(name: loadName, bundle: nil).instantiateViewController(withIdentifier: sbId) as! Self &#125;&#125;extension UIViewController: NibLoadable &#123;&#125;extension UIView: NibLoadable &#123;&#125; 然后 let writeVC = WriteViewController.loadFromStoryboard()let medalView = MedalView.loadFromNib()","categories":[],"tags":[{"name":"Swift","slug":"Swift","permalink":"http://www.calm1993.com/tags/Swift/"}]},{"title":"Swift语法糖---初始化Then","slug":"Swift/Swift语法糖---初始化Then","date":"2018-04-24T03:32:59.000Z","updated":"2018-04-24T04:47:02.000Z","comments":true,"path":"post/Swift/Swift语法糖---初始化Then.html","link":"","permalink":"http://www.calm1993.com/post/Swift/Swift语法糖---初始化Then.html","excerpt":"Then是一个swift初始化库,只有80几行的代码库,确可以让初始化变得很优雅","text":"Then是一个swift初始化库,只有80几行的代码库,确可以让初始化变得很优雅 使用then初始化AnyObject,这里以初始化控件为例 lazy var label = UILabel().then(&#123; $0.text = \"label\" $0.textColor = .blue&#125;) let redView = UIView().then &#123; (make) in make.backgroundColor = .red make.frame = CGRect(x: 50, y: 50, width: 100, height: 100)&#125; let button = UIButton().then (&#123; $0.setTitle(\"点我\", for: .normal) $0.setTitleColor(.red, for: .normal) &#125;) 如果布局这样还不简单那就只能来骚的了,Then和SnapKit一起使用的方式 let button1 = UIButton().then &#123; (make) in make.setTitle(\"登录\", for: .normal) make.setTitleColor(.black, for: .normal) view.addSubview(make) make.snp.makeConstraints(&#123; (make) in make.top.left.right.equalTo(0) make.height.equalTo(100) &#125;) &#125; 或者你还可以这样 let button2 = UIButton().then(&#123; $0.setTitle(\"登录\", for: .normal) $0.setTitleColor(.black, for: .normal) view.addSubview($0) $0.snp.makeConstraints(&#123; $0.top.equalTo(button1.snp.bottom) $0.left.right.equalTo(0) $0.height.equalTo(50) &#125;) &#125;) 其他用法 let newFrame = oldFrame.with &#123; $0.size.width = 200 $0.size.height = 100&#125;newFrame.width // 200newFrame.height // 100 UserDefaults.standard.do &#123; $0.set(\"devxoul\", forKey: \"username\") $0.set(\"devxoul@gmail.com\", forKey: \"email\") $0.synchronize()&#125; Then: Github","categories":[{"name":"Swift语法糖","slug":"Swift语法糖","permalink":"http://www.calm1993.com/categories/Swift语法糖/"}],"tags":[{"name":"Swift","slug":"Swift","permalink":"http://www.calm1993.com/tags/Swift/"}]},{"title":"Swift学习---UserDefaults","slug":"Swift/Swift学习---UserDefaults","date":"2018-04-24T02:42:59.000Z","updated":"2018-04-24T04:36:14.000Z","comments":true,"path":"post/Swift/Swift学习---UserDefaults.html","link":"","permalink":"http://www.calm1993.com/post/Swift/Swift学习---UserDefaults.html","excerpt":"UserDefaults的三种优雅使用方式","text":"UserDefaults的三种优雅使用方式 第一种实现方式 首先定义一个UserDefaultsSettable的协议 protocol UserDefaultsSettable &#123; associatedtype defaultKeys: RawRepresentable static var token: String? &#123; get &#125;&#125; 然后对协议进行拓展 extension UserDefaultsSettable where defaultKeys.RawValue == String &#123; static var token: String? &#123; return nil &#125; /// 对key加密 static func forKey(_ key: defaultKeys) -&gt; String &#123; var string = String(format: \"%@_%@\", arguments: [String(describing: self), key.rawValue]) if let token = token &#123; string += String(format: \"_%@\", token) &#125;// return string.md5 return string &#125; // setter static func set(_ value: String?, forKey key: defaultKeys) &#123; UserDefaults.standard.set(value, forKey: forKey(key)) &#125; static func set(_ value: Bool, forKey key: defaultKeys) &#123; UserDefaults.standard.set(value, forKey: forKey(key)) &#125; static func set(_ value: Int, forKey key: defaultKeys) &#123; UserDefaults.standard.set(value, forKey: forKey(key)) &#125; static func set(_ value: Float, forKey key: defaultKeys) &#123; UserDefaults.standard.set(value, forKey: forKey(key)) &#125; static func set(_ value: Double, forKey key: defaultKeys) &#123; UserDefaults.standard.set(value, forKey: forKey(key)) &#125; static func set(_ value: URL?, forKey key: defaultKeys) &#123; UserDefaults.standard.set(value, forKey: forKey(key)) &#125; static func set(_ value: Any?, forKey key: defaultKeys) &#123; UserDefaults.standard.set(value, forKey: forKey(key)) &#125; static func set&lt;T: Encodable&gt;(model: T?, forKey key: defaultKeys) &#123; UserDefaults.standard.set(model: model, forKey: forKey(key)) &#125; /// getter static func string(forKey key: defaultKeys) -&gt; String? &#123; return UserDefaults.standard.string(forKey: forKey(key)) &#125; static func bool(forKey key: defaultKeys) -&gt; Bool &#123; return UserDefaults.standard.bool(forKey: forKey(key)) &#125; static func integer(forKey key: defaultKeys) -&gt; Int &#123; return UserDefaults.standard.integer(forKey: forKey(key)) &#125; static func float(forKey key: defaultKeys) -&gt; Float &#123; return UserDefaults.standard.float(forKey: forKey(key)) &#125; static func double(forKey key: defaultKeys) -&gt; Double &#123; return UserDefaults.standard.double(forKey: forKey(key)) &#125; static func url(forKey key: defaultKeys) -&gt; URL? &#123; return UserDefaults.standard.url(forKey: forKey(key)) &#125; static func object(forKey key: defaultKeys) -&gt; Any? &#123; return UserDefaults.standard.object(forKey: forKey(key)) &#125; static func model&lt;T: Decodable&gt;(forKey key: defaultKeys) -&gt; T? &#123; return UserDefaults.standard.model(forKey: forKey(key)) &#125; /// remove static func remove(forKey key: defaultKeys)&#123; return UserDefaults.standard.removeObject(forKey: forKey(key)) &#125;&#125;/// 对UserDefaults扩展支持model存储extension UserDefaults &#123; func set&lt;T: Encodable&gt;(model: T?, forKey key: String) &#123; if let model = model &#123; let encoded = try? JSONEncoder().encode(model) UserDefaults.standard.set(encoded, forKey: key) &#125; else &#123; UserDefaults.standard.removeObject(forKey: key) &#125; &#125; func model&lt;T: Decodable&gt;(forKey key: String) -&gt; T? &#123; if let data = UserDefaults.standard.data(forKey: key) &#123; return try? JSONDecoder().decode(T.self, from: data) &#125; return nil &#125;&#125; 如何使用 首先定义使用的defaultKeys枚举 extension UserDefaults &#123; // 设置信息 enum SettingInfo: UserDefaultsSettable &#123; enum defaultKeys: String &#123; case dxva case background &#125; &#125; // 用户信息 enum UserInfo: UserDefaultsSettable &#123; enum defaultKeys: String &#123; case isLogin case name &#125; &#125;&#125; 存取 //存储 UserDefaults.UserInfo.set(\"XXX\", forKey: .name) UserDefaults.SettingInfo.set(false, forKey: .background) //取出 UserDefaults.UserInfo.string(forKey: .name) UserDefaults.SettingInfo.bool(forKey: .background) 第二种方式实现方式 同样首先定义一个UserDefaultSettable的协议 public protocol UserDefaultSettable &#123; var rawValueKey: String &#123; get &#125; static var token: String? &#123; get &#125;&#125; 然后对协议进行拓展 // MARK: - 生成rawValueKeypublic extension UserDefaultSettable where Self: RawRepresentable, Self.RawValue == String &#123; static var token: String? &#123; return nil &#125; fileprivate func forKey(_ key: String) -&gt; String &#123; var string = String(format: \"%@\", arguments: [key]) if let token = Self.token &#123; string += String(format: \"_%@\", token) &#125; return string &#125; public var rawValueKey: String &#123; return forKey(\"\\(Self.self).\\(rawValue)\") &#125;&#125;// MARK: - setterpublic extension UserDefaultSettable where Self: RawRepresentable, Self.RawValue == String &#123; public func store(_ value: Any?)&#123; UserDefaults.standard.set(value, forKey: rawValueKey) &#125; public func store(_ value: String?) &#123; UserDefaults.standard.set(value, forKey: rawValueKey) &#125; public func store(_ value: Bool?) &#123; UserDefaults.standard.set(value, forKey: rawValueKey) &#125; public func store(_ value: Int?) &#123; UserDefaults.standard.set(value, forKey: rawValueKey) &#125; public func store(_ value: Float?) &#123; UserDefaults.standard.set(value, forKey: rawValueKey) &#125; func store(_ value: Double?) &#123; UserDefaults.standard.set(value, forKey: rawValueKey) &#125; func store(_ value: URL?) &#123; UserDefaults.standard.set(value, forKey: rawValueKey) &#125; func store&lt;T: Encodable&gt;(_ value: T?) &#123; UserDefaults.standard.set(model: value, forKey: rawValueKey) &#125;&#125;// MARK: - getterpublic extension UserDefaultSettable where Self: RawRepresentable, Self.RawValue == String &#123;// typealias T = Decodable public var value: Any? &#123; return UserDefaults.standard.value(forKey: rawValueKey) &#125; public var string: String? &#123; return value as? String &#125; public var bool: Bool? &#123; return UserDefaults.standard.bool(forKey: rawValueKey) &#125; public var int: Int? &#123; return UserDefaults.standard.integer(forKey: rawValueKey) &#125; public var float: Float? &#123; return UserDefaults.standard.float(forKey: rawValueKey) &#125; public var double: Double? &#123; return UserDefaults.standard.double(forKey: rawValueKey) &#125; public var url: URL? &#123; return UserDefaults.standard.url(forKey: rawValueKey) &#125; func model&lt;T: Decodable&gt;() -&gt; T? &#123; return UserDefaults.standard.model(forKey: rawValueKey) &#125;&#125;// MARK: - removedpublic extension UserDefaultSettable where Self: RawRepresentable, Self.RawValue == String &#123; public func removed() &#123; UserDefaults.standard.removeObject(forKey: rawValueKey) &#125;&#125; 如何使用 同样首先定义key的枚举 extension UserDefaults &#123; enum UserInfo: String,UserDefaultSettable &#123; case name case url case isLogin case jump static var token: String &#123; return \"11111111\" &#125; &#125;&#125; 存取 //存储UserDefaults.UserInfo.name.store(\"小明\")UserDefaults.UserInfo.isLogin.store(false)//取出let name = UserDefaults.UserInfo.name.stringlet isLogin = UserDefaults.UserInfo.isLogin.bool 第三中方式一个github上的第三方库也可以很优雅的写UserDefaults SwiftyUserDefaults LEE \bSwift里我用这个姿势写UserDefaults","categories":[{"name":"Swift","slug":"Swift","permalink":"http://www.calm1993.com/categories/Swift/"}],"tags":[{"name":"Swift","slug":"Swift","permalink":"http://www.calm1993.com/tags/Swift/"}]},{"title":"ReactiveCocoa之进阶篇","slug":"iOS/ReactiveCocoa之进阶篇","date":"2018-03-13T01:50:38.000Z","updated":"2018-03-13T02:28:26.000Z","comments":true,"path":"post/iOS/ReactiveCocoa之进阶篇.html","link":"","permalink":"http://www.calm1993.com/post/iOS/ReactiveCocoa之进阶篇.html","excerpt":"","text":"ReactiveCocoa之基础篇 ReactiveCocoa之进阶篇 1.ReactiveCocoa常见操作方法介绍。 1.1 ReactiveCocoa操作须知 所有的信号（RACSignal）都可以进行操作处理，因为所有操作方法都定义在RACStream.h中，而RACSignal继承RACStream。 1.2 ReactiveCocoa操作思想 运用的是Hook（钩子）思想，Hook是一种用于改变API(应用程序编程接口：方法)执行结果的技术. Hook用处：截获API调用的技术。 Hook原理：在每次调用一个API返回结果之前，先执行你自己的方法，改变结果的输出。 RAC开发方式：RAC中核心开发方式，也是绑定，之前的开发方式是赋值，而用RAC开发，应该把重心放在绑定，也就是可以在创建一个对象的时候，就绑定好以后想要做的事情，而不是等赋值之后在去做事情。 列如：把数据展示到控件上，之前都是重写控件的setModel方法，用RAC就可以在一开始创建控件的时候，就绑定好数据。 1.3 ReactiveCocoa核心方法bind ReactiveCocoa操作的核心方法是bind（绑定）,给RAC中的信号进行绑定，只要信号一发送数据，就能监听到，从而把发送数据改成自己想要的数据。 在开发中很少使用bind方法，bind属于RAC中的底层方法，RAC已经封装了很多好用的其他方法，底层都是调用bind，用法比bind简单. bind方法简单介绍和使用。 // 假设想监听文本框的内容，并且在每次输出结果的时候，都在文本框的内容拼接一段文字“输出：”// 方式一:在返回结果后，拼接。 [_textField.rac_textSignal subscribeNext:^(id x) &#123; NSLog(@\"输出:%@\",x); &#125;];// 方式二:在返回结果前，拼接，使用RAC中bind方法做处理。// bind方法参数:需要传入一个返回值是RACStreamBindBlock的block参数// RACStreamBindBlock是一个block的类型，返回值是信号，参数（value,stop），因此参数的block返回值也是一个block。// RACStreamBindBlock:// 参数一(value):表示接收到信号的原始值，还没做处理// 参数二(*stop):用来控制绑定Block，如果*stop = yes,那么就会结束绑定。// 返回值：信号，做好处理，在通过这个信号返回出去，一般使用RACReturnSignal,需要手动导入头文件RACReturnSignal.h。// bind方法使用步骤:// 1.传入一个返回值RACStreamBindBlock的block。// 2.描述一个RACStreamBindBlock类型的bindBlock作为block的返回值。// 3.描述一个返回结果的信号，作为bindBlock的返回值。// 注意：在bindBlock中做信号结果的处理。// 底层实现:// 1.源信号调用bind,会重新创建一个绑定信号。// 2.当绑定信号被订阅，就会调用绑定信号中的didSubscribe，生成一个bindingBlock。// 3.当源信号有内容发出，就会把内容传递到bindingBlock处理，调用bindingBlock(value,stop)// 4.调用bindingBlock(value,stop)，会返回一个内容处理完成的信号（RACReturnSignal）。// 5.订阅RACReturnSignal，就会拿到绑定信号的订阅者，把处理完成的信号内容发送出来。// 注意:不同订阅者，保存不同的nextBlock，看源码的时候，一定要看清楚订阅者是哪个。// 这里需要手动导入#import &lt;ReactiveCocoa/RACReturnSignal.h&gt;，才能使用RACReturnSignal。[[_textField.rac_textSignal bind:^RACStreamBindBlock&#123; // 什么时候调用: // block作用:表示绑定了一个信号. return ^RACStream *(id value, BOOL *stop)&#123; // 什么时候调用block:当信号有新的值发出，就会来到这个block。 // block作用:做返回值的处理 // 做好处理，通过信号返回出去. return [RACReturnSignal return:[NSString stringWithFormat:@\"输出:%@\",value]]; &#125;;&#125;] subscribeNext:^(id x) &#123; NSLog(@\"%@\",x);&#125;]; 1.4ReactiveCocoa操作方法之映射(flattenMap,Map) flattenMap，Map用于把源信号内容映射成新的内容。 flattenMap简单使用 // 监听文本框的内容改变，把结构重新映射成一个新值.// flattenMap作用:把源信号的内容映射成一个新的信号，信号可以是任意类型。 // flattenMap使用步骤: // 1.传入一个block，block类型是返回值RACStream，参数value // 2.参数value就是源信号的内容，拿到源信号的内容做处理 // 3.包装成RACReturnSignal信号，返回出去。 // flattenMap底层实现: // 0.flattenMap内部调用bind方法实现的,flattenMap中block的返回值，会作为bind中bindBlock的返回值。 // 1.当订阅绑定信号，就会生成bindBlock。 // 2.当源信号发送内容，就会调用bindBlock(value, *stop) // 3.调用bindBlock，内部就会调用flattenMap的block，flattenMap的block作用：就是把处理好的数据包装成信号。 // 4.返回的信号最终会作为bindBlock中的返回信号，当做bindBlock的返回信号。 // 5.订阅bindBlock的返回信号，就会拿到绑定信号的订阅者，把处理完成的信号内容发送出来。 [[_textField.rac_textSignal flattenMap:^RACStream *(id value) &#123; // block什么时候 : 源信号发出的时候，就会调用这个block。 // block作用 : 改变源信号的内容。 // 返回值：绑定信号的内容. return [RACReturnSignal return:[NSString stringWithFormat:@\"输出:%@\",value]]; &#125;] subscribeNext:^(id x) &#123; // 订阅绑定信号，每当源信号发送内容，做完处理，就会调用这个block。 NSLog(@\"%@\",x); &#125;]; Map简单使用: // 监听文本框的内容改变，把结构重新映射成一个新值. // Map作用:把源信号的值映射成一个新的值 // Map使用步骤: // 1.传入一个block,类型是返回对象，参数是value // 2.value就是源信号的内容，直接拿到源信号的内容做处理 // 3.把处理好的内容，直接返回就好了，不用包装成信号，返回的值，就是映射的值。 // Map底层实现: // 0.Map底层其实是调用flatternMap,Map中block中的返回的值会作为flatternMap中block中的值。 // 1.当订阅绑定信号，就会生成bindBlock。 // 3.当源信号发送内容，就会调用bindBlock(value, *stop) // 4.调用bindBlock，内部就会调用flattenMap的block // 5.flattenMap的block内部会调用Map中的block，把Map中的block返回的内容包装成返回的信号。 // 5.返回的信号最终会作为bindBlock中的返回信号，当做bindBlock的返回信号。 // 6.订阅bindBlock的返回信号，就会拿到绑定信号的订阅者，把处理完成的信号内容发送出来。 [[_textField.rac_textSignal map:^id(id value) &#123; // 当源信号发出，就会调用这个block，修改源信号的内容 // 返回值：就是处理完源信号的内容。 return [NSString stringWithFormat:@\"输出:%@\",value]; &#125;] subscribeNext:^(id x) &#123; NSLog(@\"%@\",x); &#125;]; FlatternMap和Map的区别 1.FlatternMap中的Block返回信号。 2.Map中的Block返回对象。 3.开发中，如果信号发出的值不是信号，映射一般使用Map 4.开发中，如果信号发出的值是信号，映射一般使用FlatternMap。 总结：signalOfsignals用FlatternMap。 // 创建信号中的信号RACSubject *signalOfsignals = [RACSubject subject];RACSubject *signal = [RACSubject subject];[[signalOfsignals flattenMap:^RACStream *(id value) &#123; // 当signalOfsignals的signals发出信号才会调用 return value;&#125;] subscribeNext:^(id x) &#123; // 只有signalOfsignals的signal发出信号才会调用，因为内部订阅了bindBlock中返回的信号，也就是flattenMap返回的信号。 // 也就是flattenMap返回的信号发出内容，才会调用。 NSLog(@\"%@aaa\",x);&#125;];// 信号的信号发送信号[signalOfsignals sendNext:signal];// 信号发送内容[signal sendNext:@1]; 1.5 ReactiveCocoa操作方法之组合。 concat:按一定顺序拼接信号，当多个信号发出的时候，有顺序的接收信号。 RACSignal *signalA = [RACSignal createSignal:^RACDisposable *(id&lt;RACSubscriber&gt; subscriber) &#123; [subscriber sendNext:@1]; [subscriber sendCompleted]; return nil;&#125;];RACSignal *signalB = [RACSignal createSignal:^RACDisposable *(id&lt;RACSubscriber&gt; subscriber) &#123; [subscriber sendNext:@2]; return nil;&#125;];// 把signalA拼接到signalB后，signalA发送完成，signalB才会被激活。RACSignal *concatSignal = [signalA concat:signalB];// 以后只需要面对拼接信号开发。// 订阅拼接的信号，不需要单独订阅signalA，signalB// 内部会自动订阅。// 注意：第一个信号必须发送完成，第二个信号才会被激活[concatSignal subscribeNext:^(id x) &#123; NSLog(@\"%@\",x);&#125;];// concat底层实现:// 1.当拼接信号被订阅，就会调用拼接信号的didSubscribe// 2.didSubscribe中，会先订阅第一个源信号（signalA）// 3.会执行第一个源信号（signalA）的didSubscribe// 4.第一个源信号（signalA）didSubscribe中发送值，就会调用第一个源信号（signalA）订阅者的nextBlock,通过拼接信号的订阅者把值发送出来.// 5.第一个源信号（signalA）didSubscribe中发送完成，就会调用第一个源信号（signalA）订阅者的completedBlock,订阅第二个源信号（signalB）这时候才激活（signalB）。// 6.订阅第二个源信号（signalB）,执行第二个源信号（signalB）的didSubscribe// 7.第二个源信号（signalA）didSubscribe中发送值,就会通过拼接信号的订阅者把值发送出来. then:用于连接两个信号，当第一个信号完成，才会连接then返回的信号。 // then:用于连接两个信号，当第一个信号完成，才会连接then返回的信号// 注意使用then，之前信号的值会被忽略掉.// 底层实现：1、先过滤掉之前的信号发出的值。2.使用concat连接then返回的信号[[[RACSignal createSignal:^RACDisposable *(id&lt;RACSubscriber&gt; subscriber) &#123; [subscriber sendNext:@1]; [subscriber sendCompleted]; return nil;&#125;] then:^RACSignal *&#123; return [RACSignal createSignal:^RACDisposable *(id&lt;RACSubscriber&gt; subscriber) &#123; [subscriber sendNext:@2]; return nil; &#125;];&#125;] subscribeNext:^(id x) &#123; // 只能接收到第二个信号的值，也就是then返回信号的值 NSLog(@\"%@\",x);&#125;]; merge:把多个信号合并为一个信号，任何一个信号有新值的时候就会调用. // merge:把多个信号合并成一个信号//创建多个信号RACSignal *signalA = [RACSignal createSignal:^RACDisposable *(id&lt;RACSubscriber&gt; subscriber) &#123; [subscriber sendNext:@1]; return nil;&#125;];RACSignal *signalB = [RACSignal createSignal:^RACDisposable *(id&lt;RACSubscriber&gt; subscriber) &#123; [subscriber sendNext:@2]; return nil;&#125;];// 合并信号,任何一个信号发送数据，都能监听到.RACSignal *mergeSignal = [signalA merge:signalB];[mergeSignal subscribeNext:^(id x) &#123; NSLog(@\"%@\",x);&#125;];// 底层实现：// 1.合并信号被订阅的时候，就会遍历所有信号，并且发出这些信号。// 2.每发出一个信号，这个信号就会被订阅// 3.也就是合并信号一被订阅，就会订阅里面所有的信号。// 4.只要有一个信号被发出就会被监听。 zipWith:把两个信号压缩成一个信号，只有当两个信号同时发出信号内容时，并且把两个信号的内容合并成一个元组，才会触发压缩流的next事件。 RACSignal *signalA = [RACSignal createSignal:^RACDisposable *(id&lt;RACSubscriber&gt; subscriber) &#123; [subscriber sendNext:@1]; return nil;&#125;];RACSignal *signalB = [RACSignal createSignal:^RACDisposable *(id&lt;RACSubscriber&gt; subscriber) &#123; [subscriber sendNext:@2]; return nil;&#125;];// 压缩信号A，信号BRACSignal *zipSignal = [signalA zipWith:signalB];[zipSignal subscribeNext:^(id x) &#123; NSLog(@\"%@\",x);&#125;];// 底层实现:// 1.定义压缩信号，内部就会自动订阅signalA，signalB// 2.每当signalA或者signalB发出信号，就会判断signalA，signalB有没有发出个信号，有就会把最近发出的信号都包装成元组发出。 combineLatest:将多个信号合并起来，并且拿到各个信号的最新的值,必须每个合并的signal至少都有过一次sendNext，才会触发合并的信号。 RACSignal *signalA = [RACSignal createSignal:^RACDisposable *(id&lt;RACSubscriber&gt; subscriber) &#123; [subscriber sendNext:@1]; return nil;&#125;];RACSignal *signalB = [RACSignal createSignal:^RACDisposable *(id&lt;RACSubscriber&gt; subscriber) &#123; [subscriber sendNext:@2]; return nil;&#125;];// 把两个信号组合成一个信号,跟zip一样，没什么区别RACSignal *combineSignal = [signalA combineLatestWith:signalB];[combineSignal subscribeNext:^(id x) &#123; NSLog(@\"%@\",x);&#125;];// 底层实现：// 1.当组合信号被订阅，内部会自动订阅signalA，signalB,必须两个信号都发出内容，才会被触发。// 2.并且把两个信号组合成元组发出。 reduce聚合:用于信号发出的内容是元组，把信号发出元组的值聚合成一个值 RACSignal *signalA = [RACSignal createSignal:^RACDisposable *(id&lt;RACSubscriber&gt; subscriber) &#123; [subscriber sendNext:@1]; return nil; &#125;]; RACSignal *signalB = [RACSignal createSignal:^RACDisposable *(id&lt;RACSubscriber&gt; subscriber) &#123; [subscriber sendNext:@2]; return nil; &#125;]; // 聚合 // 常见的用法，（先组合在聚合）。combineLatest:(id&lt;NSFastEnumeration&gt;)signals reduce:(id (^)())reduceBlock // reduce中的block简介: // reduceblcok中的参数，有多少信号组合，reduceblcok就有多少参数，每个参数就是之前信号发出的内容 // reduceblcok的返回值：聚合信号之后的内容。RACSignal *reduceSignal = [RACSignal combineLatest:@[signalA,signalB] reduce:^id(NSNumber *num1 ,NSNumber *num2)&#123; return [NSString stringWithFormat:@\"%@ %@\",num1,num2];&#125;]; [reduceSignal subscribeNext:^(id x) &#123; NSLog(@\"%@\",x); &#125;]; // 底层实现: // 1.订阅聚合信号，每次有内容发出，就会执行reduceblcok，把信号内容转换成reduceblcok返回的值。 1.6 ReactiveCocoa操作方法之过滤。 filter:过滤信号，使用它可以获取满足条件的信号. // 过滤:// 每次信号发出，会先执行过滤条件判断.[_textField.rac_textSignal filter:^BOOL(NSString *value) &#123; return value.length &gt; 3;&#125;]; ignore:忽略完某些值的信号. // 内部调用filter过滤，忽略掉ignore的值[[_textField.rac_textSignal ignore:@\"1\"] subscribeNext:^(id x) &#123; NSLog(@\"%@\",x);&#125;]; distinctUntilChanged:当上一次的值和当前的值有明显的变化就会发出信号，否则会被忽略掉。 // 过滤，当上一次和当前的值不一样，就会发出内容。// 在开发中，刷新UI经常使用，只有两次数据不一样才需要刷新[[_textField.rac_textSignal distinctUntilChanged] subscribeNext:^(id x) &#123; NSLog(@\"%@\",x);&#125;]; take:从开始一共取N次的信号 // 1、创建信号RACSubject *signal = [RACSubject subject];// 2、处理信号，订阅信号[[signal take:1] subscribeNext:^(id x) &#123; NSLog(@\"%@\",x);&#125;];// 3.发送信号[signal sendNext:@1];[signal sendNext:@2]; takeLast:取最后N次的信号,前提条件，订阅者必须调用完成，因为只有完成，就知道总共有多少信号. // 1、创建信号RACSubject *signal = [RACSubject subject];// 2、处理信号，订阅信号[[signal takeLast:1] subscribeNext:^(id x) &#123; NSLog(@\"%@\",x);&#125;];// 3.发送信号[signal sendNext:@1];[signal sendNext:@2];[signal sendCompleted]; takeUntil:(RACSignal *):获取信号直到执行完这个信号 // 监听文本框的改变，知道当前对象被销毁[_textField.rac_textSignal takeUntil:self.rac_willDeallocSignal]; skip:(NSUInteger):跳过几个信号,不接受。 // 表示输入第一次，不会被监听到，跳过第一次发出的信号[[_textField.rac_textSignal skip:1] subscribeNext:^(id x) &#123; NSLog(@\"%@\",x);&#125;]; switchToLatest:用于signalOfSignals（信号的信号），有时候信号也会发出信号，会在signalOfSignals中，获取signalOfSignals发送的最新信号。 RACSubject *signalOfSignals = [RACSubject subject];RACSubject *signal = [RACSubject subject];[signalOfSignals sendNext:signal];[signal sendNext:@1];// 获取信号中信号最近发出信号，订阅最近发出的信号。// 注意switchToLatest：只能用于信号中的信号[signalOfSignals.switchToLatest subscribeNext:^(id x) &#123; NSLog(@\"%@\",x);&#125;]; 1.7 ReactiveCocoa操作方法之秩序。 doNext: 执行Next之前，会先执行这个Block doCompleted: 执行sendCompleted之前，会先执行这个Block [[[[RACSignal createSignal:^RACDisposable *(id&lt;RACSubscriber&gt; subscriber) &#123; [subscriber sendNext:@1]; [subscriber sendCompleted]; return nil; &#125;] doNext:^(id x) &#123; // 执行[subscriber sendNext:@1];之前会调用这个Block NSLog(@\"doNext\");; &#125;] doCompleted:^&#123; // 执行[subscriber sendCompleted];之前会调用这个Block NSLog(@\"doCompleted\");; &#125;] subscribeNext:^(id x) &#123; NSLog(@\"%@\",x); &#125;]; 1.8 ReactiveCocoa操作方法之线程。 deliverOn: 内容传递切换到制定线程中，副作用在原来线程中,把在创建信号时block中的代码称之为副作用。 subscribeOn: 内容传递和副作用都会切换到制定线程中。 1.9 ReactiveCocoa操作方法之时间。 timeout：超时，可以让一个信号在一定的时间后，自动报错。 RACSignal *signal = [[RACSignal createSignal:^RACDisposable *(id&lt;RACSubscriber&gt; subscriber) &#123; return nil;&#125;] timeout:1 onScheduler:[RACScheduler currentScheduler]];[signal subscribeNext:^(id x) &#123; NSLog(@\"%@\",x);&#125; error:^(NSError *error) &#123; // 1秒后会自动调用 NSLog(@\"%@\",error);&#125;]; interval 定时：每隔一段时间发出信号 [[RACSignal interval:1 onScheduler:[RACScheduler currentScheduler]] subscribeNext:^(id x) &#123; NSLog(@\"%@\",x); &#125;]; delay 延迟发送next。 RACSignal *signal = [[[RACSignal createSignal:^RACDisposable *(id&lt;RACSubscriber&gt; subscriber) &#123; [subscriber sendNext:@1]; return nil;&#125;] delay:2] subscribeNext:^(id x) &#123; NSLog(@\"%@\",x);&#125;]; 1.9 ReactiveCocoa操作方法之重复。 retry重试 ：只要失败，就会重新执行创建信号中的block,直到成功. __block int i = 0;[[[RACSignal createSignal:^RACDisposable *(id&lt;RACSubscriber&gt; subscriber) &#123; if (i == 10) &#123; [subscriber sendNext:@1]; &#125;else&#123; NSLog(@\"接收到错误\"); [subscriber sendError:nil]; &#125; i++; return nil;&#125;] retry] subscribeNext:^(id x) &#123; NSLog(@\"%@\",x);&#125; error:^(NSError *error) &#123;&#125;]; replay重放：当一个信号被多次订阅,反复播放内容 RACSignal *signal = [[RACSignal createSignal:^RACDisposable *(id&lt;RACSubscriber&gt; subscriber) &#123; [subscriber sendNext:@1]; [subscriber sendNext:@2]; return nil;&#125;] replay];[signal subscribeNext:^(id x) &#123; NSLog(@\"第一个订阅者%@\",x);&#125;];[signal subscribeNext:^(id x) &#123; NSLog(@\"第二个订阅者%@\",x);&#125;]; throttle节流:当某个信号发送比较频繁时，可以使用节流，在某一段时间不发送信号内容，过了一段时间获取信号的最新内容发出。 RACSubject *signal = [RACSubject subject];_signal = signal;// 节流，在一定时间（1秒）内，不接收任何信号内容，过了这个时间（1秒）获取最后发送的信号内容发出。[[signal throttle:1] subscribeNext:^(id x) &#123; NSLog(@\"%@\",x);&#125;]; 2.介绍MVVM架构思想。2.1 程序为什么要架构：便于程序员开发和维护代码。 2.2 常见的架构思想: MVC M:模型 V:视图 C:控制器 MVVM M:模型 V:视图+控制器 VM:视图模型 MVCS M:模型 V:视图 C:控制器 C:服务类 VIPER V:视图 I:交互器 P:展示器 E:实体 R:路由 (http://www.cocoachina.com/ios/20140703/9016.html) 2.3 MVVM介绍 模型(M):保存视图数据。 视图+控制器(V):展示内容 + 如何展示 视图模型(VM):处理展示的业务逻辑，包括按钮的点击，数据的请求和解析等等。 3.ReactiveCocoa + MVVM 实战一：登录界面 3.1需求+分析+步骤 /* 需求：1.监听两个文本框的内容，有内容才允许按钮点击 2.默认登录请求. 用MVVM：实现，之前界面的所有业务逻辑 分析：1.之前界面的所有业务逻辑都交给控制器做处理 2.在MVVM架构中把控制器的业务全部搬去VM模型，也就是每个控制器对应一个VM模型. 步骤：1.创建LoginViewModel类，处理登录界面业务逻辑. 2.这个类里面应该保存着账号的信息，创建一个账号Account模型 3.LoginViewModel应该保存着账号信息Account模型。 4.需要时刻监听Account模型中的账号和密码的改变，怎么监听？ 5.在非RAC开发中，都是习惯赋值，在RAC开发中，需要改变开发思维，由赋值转变为绑定，可以在一开始初始化的时候，就给Account模型中的属性绑定，并不需要重写set方法。 6.每次Account模型的值改变，就需要判断按钮能否点击，在VM模型中做处理，给外界提供一个能否点击按钮的信号. 7.这个登录信号需要判断Account中账号和密码是否有值，用KVO监听这两个值的改变，把他们聚合成登录信号. 8.监听按钮的点击，由VM处理，应该给VM声明一个RACCommand，专门处理登录业务逻辑. 9.执行命令，把数据包装成信号传递出去 10.监听命令中信号的数据传递 11.监听命令的执行时刻 */ 3.2 控制器的代码 @interface ViewController ()@property (nonatomic, strong) LoginViewModel *loginViewModel;@property (weak, nonatomic) IBOutlet UITextField *accountField;@property (weak, nonatomic) IBOutlet UITextField *pwdField;@property (weak, nonatomic) IBOutlet UIButton *loginBtn;@end- (LoginViewModel *)loginViewModel&#123; if (_loginViewModel == nil) &#123; _loginViewModel = [[LoginViewModel alloc] init]; &#125; return _loginViewModel;&#125;// 视图模型绑定- (void)bindModel&#123; // 给模型的属性绑定信号 // 只要账号文本框一改变，就会给account赋值 RAC(self.loginViewModel.account, account) = _accountField.rac_textSignal; RAC(self.loginViewModel.account, pwd) = _pwdField.rac_textSignal; // 绑定登录按钮 RAC(self.loginBtn,enabled) = self.loginViewModel.enableLoginSignal; // 监听登录按钮点击 [[_loginBtn rac_signalForControlEvents:UIControlEventTouchUpInside] subscribeNext:^(id x) &#123; // 执行登录事件 [self.loginViewModel.LoginCommand execute:nil]; &#125;];&#125; 3.3 VM的代码 @interface LoginViewModel : NSObject@property (nonatomic, strong) Account *account;// 是否允许登录的信号@property (nonatomic, strong, readonly) RACSignal *enableLoginSignal;@property (nonatomic, strong, readonly) RACCommand *LoginCommand;@end@implementation LoginViewModel- (Account *)account&#123; if (_account == nil) &#123; _account = [[Account alloc] init]; &#125; return _account;&#125;- (instancetype)init&#123; if (self = [super init]) &#123; [self initialBind]; &#125; return self;&#125;// 初始化绑定- (void)initialBind&#123; // 监听账号的属性值改变，把他们聚合成一个信号。 _enableLoginSignal = [RACSignal combineLatest:@[RACObserve(self.account, account),RACObserve(self.account, pwd)] reduce:^id(NSString *account,NSString *pwd)&#123; return @(account.length &amp;&amp; pwd.length); &#125;]; // 处理登录业务逻辑 _LoginCommand = [[RACCommand alloc] initWithSignalBlock:^RACSignal *(id input) &#123; NSLog(@\"点击了登录\"); return [RACSignal createSignal:^RACDisposable *(id&lt;RACSubscriber&gt; subscriber) &#123; // 模仿网络延迟 dispatch_after(dispatch_time(DISPATCH_TIME_NOW, (int64_t)(0.5 * NSEC_PER_SEC)), dispatch_get_main_queue(), ^&#123; [subscriber sendNext:@\"登录成功\"]; // 数据传送完毕，必须调用完成，否则命令永远处于执行状态 [subscriber sendCompleted]; &#125;); return nil; &#125;]; &#125;]; // 监听登录产生的数据 [_LoginCommand.executionSignals.switchToLatest subscribeNext:^(id x) &#123; if ([x isEqualToString:@\"登录成功\"]) &#123; NSLog(@\"登录成功\"); &#125; &#125;]; // 监听登录状态 [[_LoginCommand.executing skip:1] subscribeNext:^(id x) &#123; if ([x isEqualToNumber:@(YES)]) &#123; // 正在登录ing... // 用蒙版提示 [MBProgressHUD showMessage:@\"正在登录...\"]; &#125;else &#123; // 登录成功 // 隐藏蒙版 [MBProgressHUD hideHUD]; &#125; &#125;];&#125; 4.ReactiveCocoa + MVVM 实战二：网络请求数据 4.1 接口：这里先给朋友介绍一个免费的网络数据接口，豆瓣。可以经常用来练习一些网络请求的小Demo. 4.2 需求+分析+步骤 /* 需求：请求豆瓣图书信息，url:https://api.douban.com/v2/book/search?q=基础 分析：请求一样，交给VM模型管理 步骤: 1.控制器提供一个视图模型（requesViewModel），处理界面的业务逻辑 2.VM提供一个命令，处理请求业务逻辑 3.在创建命令的block中，会把请求包装成一个信号，等请求成功的时候，就会把数据传递出去。 4.请求数据成功，应该把字典转换成模型，保存到视图模型中，控制器想用就直接从视图模型中获取。 5.假设控制器想展示内容到tableView，直接让视图模型成为tableView的数据源，把所有的业务逻辑交给视图模型去做，这样控制器的代码就非常少了。 */ 4.3控制器代码 @interface ViewController ()@property (nonatomic, weak) UITableView *tableView;@property (nonatomic, strong) RequestViewModel *requesViewModel;@end@implementation ViewController- (RequestViewModel *)requesViewModel&#123; if (_requesViewModel == nil) &#123; _requesViewModel = [[RequestViewModel alloc] init]; &#125; return _requesViewModel;&#125;- (void)viewDidLoad &#123; [super viewDidLoad]; // Do any additional setup after loading the view, typically from a nib. // 创建tableView UITableView *tableView = [[UITableView alloc] initWithFrame:self.view.bounds]; tableView.dataSource = self.requesViewModel; self.requesViewModel.tableView = tableView; [self.view addSubview:tableView]; // 执行请求 [self.requesViewModel.reuqesCommand execute:nil];&#125;@end 4.4视图模型(VM)代码 @interface RequestViewModel : NSObject&lt;UITableViewDataSource&gt; // 请求命令 @property (nonatomic, strong, readonly) RACCommand *reuqesCommand; //模型数组 @property (nonatomic, strong, readonly) NSArray *models; // 控制器中的view @property (nonatomic, weak) UITableView *tableView;@end@implementation RequestViewModel- (instancetype)init&#123; if (self = [super init]) &#123; [self initialBind]; &#125; return self;&#125;- (void)initialBind&#123; _reuqesCommand = [[RACCommand alloc] initWithSignalBlock:^RACSignal *(id input) &#123; RACSignal *requestSignal = [RACSignal createSignal:^RACDisposable *(id&lt;RACSubscriber&gt; subscriber) &#123; NSMutableDictionary *parameters = [NSMutableDictionary dictionary]; parameters[@\"q\"] = @\"基础\"; // 发送请求 [[AFHTTPRequestOperationManager manager] GET:@\"https://api.douban.com/v2/book/search\" parameters:parameters success:^(AFHTTPRequestOperation * _Nonnull operation, id _Nonnull responseObject) &#123; NSLog(@\"%@\",responseObject); // 请求成功调用 // 把数据用信号传递出去 [subscriber sendNext:responseObject]; [subscriber sendCompleted]; &#125; failure:^(AFHTTPRequestOperation * _Nonnull operation, NSError * _Nonnull error) &#123; // 请求失败调用 &#125;]; return nil; &#125;]; // 在返回数据信号时，把数据中的字典映射成模型信号，传递出去 return [requestSignal map:^id(NSDictionary *value) &#123; NSMutableArray *dictArr = value[@\"books\"]; // 字典转模型，遍历字典中的所有元素，全部映射成模型，并且生成数组 NSArray *modelArr = [[dictArr.rac_sequence map:^id(id value) &#123; return [Book bookWithDict:value]; &#125;] array]; return modelArr; &#125;]; &#125;]; // 获取请求的数据 [_reuqesCommand.executionSignals.switchToLatest subscribeNext:^(NSArray *x) &#123; // 有了新数据，刷新表格 _models = x; // 刷新表格 [self.tableView reloadData]; &#125;];&#125;#pragma mark - UITableViewDataSource- (NSInteger)tableView:(UITableView *)tableView numberOfRowsInSection:(NSInteger)section&#123; return self.models.count;&#125;- (UITableViewCell *)tableView:(UITableView *)tableView cellForRowAtIndexPath:(NSIndexPath *)indexPath&#123; static NSString *ID = @\"cell\"; UITableViewCell *cell = [tableView dequeueReusableCellWithIdentifier:ID]; if (cell == nil) &#123; cell = [[UITableViewCell alloc] initWithStyle:UITableViewCellStyleSubtitle reuseIdentifier:ID]; &#125; Book *book = self.models[indexPath.row]; cell.detailTextLabel.text = book.subtitle; cell.textLabel.text = book.title; return cell;&#125;@end","categories":[{"name":"iOS","slug":"iOS","permalink":"http://www.calm1993.com/categories/iOS/"}],"tags":[{"name":"ReactiveCocoa","slug":"ReactiveCocoa","permalink":"http://www.calm1993.com/tags/ReactiveCocoa/"}]},{"title":"ReactiveCocoa之基础篇","slug":"iOS/ReactiveCocoa之基础篇","date":"2018-03-13T01:50:38.000Z","updated":"2019-02-18T05:55:04.000Z","comments":true,"path":"post/iOS/ReactiveCocoa之基础篇.html","link":"","permalink":"http://www.calm1993.com/post/iOS/ReactiveCocoa之基础篇.html","excerpt":"","text":"ReactiveCocoa之基础篇 ReactiveCocoa之进阶篇 1.ReactiveCocoa简介ReactiveCocoa（简称为RAC）,是由Github开源的一个应用于iOS和OS开发的新框架,Cocoa是苹果整套框架的简称，因此很多苹果框架喜欢以Cocoa结尾。 2.ReactiveCocoa作用 在我们iOS开发过程中，当某些事件响应的时候，需要处理某些业务逻辑,这些事件都用不同的方式来处理。 比如按钮的点击使用action，ScrollView滚动使用delegate，属性值改变使用KVO等系统提供的方式。 其实这些事件，都可以通过RAC处理 ReactiveCocoa为事件提供了很多处理方法，而且利用RAC处理事件很方便，可以把要处理的事情，和监听的事情的代码放在一起，这样非常方便我们管理，就不需要跳到对应的方法里。非常符合我们开发中高聚合，低耦合的思想。 3.编程思想在开发中我们也不能太依赖于某个框架，否则这个框架不更新了，导致项目后期没办法维护，比如之前Facebook提供的Three20框架，在当时也是神器，但是后来不更新了，也就没什么人用了。因此我感觉学习一个框架，还是有必要了解它的编程思想。 编程思想的由来：在开发中我们会遇见各种各样的需求，经常会思考如何快速的完成这些需求，这样就会慢慢形成快速完成这些需求的思想。 先简单介绍下目前咱们已知的编程思想。 3.1 面向过程：处理事情以过程为核心，一步一步的实现。 3.2 面向对象：万物皆对象 3.3 链式编程思想：是将多个操作（多行代码）通过点号(.)链接在一起成为一句代码,使代码可读性好。a(1).b(2).c(3) 链式编程特点：方法的返回值是block,block必须有返回值（本身对象），block参数（需要操作的值） 代表：masonry框架。 3.4 响应式编程思想：不需要考虑调用顺序，只需要知道考虑结果，类似于蝴蝶效应，产生一个事件，会影响很多东西，这些事件像流一样的传播出去，然后影响结果，借用面向对象的一句话，万物皆是流。 代表：KVO运用。 3.5 函数式编程思想：是把操作尽量写成一系列嵌套的函数或者方法调用。 函数式编程本质:就是往方法中传入Block,方法中嵌套Block调用，把代码聚合起来管理 函数式编程特点：每个方法必须有返回值（本身对象）,把函数或者Block当做参数,block参数（需要操作的值）block返回值（操作结果） 代表：ReactiveCocoa。 4.ReactiveCocoa编程思想ReactiveCocoa结合了几种编程风格： 函数式编程（Functional Programming） 响应式编程（Reactive Programming） 所以，你可能听说过ReactiveCocoa被描述为函数响应式编程（FRP）框架。 以后使用RAC解决问题，就不需要考虑调用顺序，直接考虑结果，把每一次操作都写成一系列嵌套的方法中，使代码高聚合，方便管理。 5.如何导入ReactiveCocoa框架通常都会使用CocoaPods（用于管理第三方框架的插件）帮助我们导入。 PS:CocoaPods教程（http://code4app.com/article/cocoapods-install-usage） 注意： podfile如果只描述pod ‘ReactiveCocoa’, ‘~&gt; 4.0.2-alpha-1’，会导入不成功 报错信息 需要在podfile加上use_frameworks，重新pod install 才能导入成功。 6.ReactiveCocoa常见类。学习框架首要之处:个人认为先要搞清楚框架中常用的类，在RAC中最核心的类RACSiganl,搞定这个类就能用ReactiveCocoa开发了。 RACSiganl:信号类,一般表示将来有数据传递，只要有数据改变，信号内部接收到数据，就会马上发出数据。 信号类(RACSiganl)，只是表示当数据改变时，信号内部会发出数据，它本身不具备发送信号的能力，而是交给内部一个订阅者去发出。 默认一个信号都是冷信号，也就是值改变了，也不会触发，只有订阅了这个信号，这个信号才会变为热信号，值改变了才会触发。 如何订阅信号：调用信号RACSignal的subscribeNext就能订阅。 RACSiganl简单使用: // RACSignal使用步骤： // 1.创建信号 + (RACSignal *)createSignal:(RACDisposable * (^)(id&lt;RACSubscriber&gt; subscriber))didSubscribe // 2.订阅信号,才会激活信号. - (RACDisposable *)subscribeNext:(void (^)(id x))nextBlock // 3.发送信号 - (void)sendNext:(id)value // RACSignal底层实现： // 1.创建信号，首先把didSubscribe保存到信号中，还不会触发。 // 2.当信号被订阅，也就是调用signal的subscribeNext:nextBlock // 2.2 subscribeNext内部会创建订阅者subscriber，并且把nextBlock保存到subscriber中。 // 2.1 subscribeNext内部会调用siganl的didSubscribe // 3.siganl的didSubscribe中调用[subscriber sendNext:@1]; // 3.1 sendNext底层其实就是执行subscriber的nextBlock // 1.创建信号 RACSignal *siganl = [RACSignal createSignal:^RACDisposable *(id&lt;RACSubscriber&gt; subscriber) &#123; // block调用时刻：每当有订阅者订阅信号，就会调用block。 // 2.发送信号 [subscriber sendNext:@1]; // 如果不在发送数据，最好发送信号完成，内部会自动调用[RACDisposable disposable]取消订阅信号。 [subscriber sendCompleted]; return [RACDisposable disposableWithBlock:^&#123; // block调用时刻：当信号发送完成或者发送错误，就会自动执行这个block,取消订阅信号。 // 执行完Block后，当前信号就不在被订阅了。 NSLog(@\"信号被销毁\"); &#125;]; &#125;]; // 3.订阅信号,才会激活信号. [siganl subscribeNext:^(id x) &#123; // block调用时刻：每当有信号发出数据，就会调用block. NSLog(@\"接收到数据:%@\",x); &#125;]; RACSubscriber:表示订阅者的意思，用于发送信号，这是一个协议，不是一个类，只要遵守这个协议，并且实现方法才能成为订阅者。通过create创建的信号，都有一个订阅者，帮助他发送数据。 RACDisposable:用于取消订阅或者清理资源，当信号发送完成或者发送错误的时候，就会自动触发它。 使用场景:不想监听某个信号时，可以通过它主动取消订阅信号。 RACSubject:RACSubject:信号提供者，自己可以充当信号，又能发送信号。 使用场景:通常用来代替代理，有了它，就不必要定义代理了。 RACReplaySubject:重复提供信号类，RACSubject的子类。 RACReplaySubject与RACSubject区别: RACReplaySubject可以先发送信号，在订阅信号，RACSubject就不可以。 使用场景一:如果一个信号每被订阅一次，就需要把之前的值重复发送一遍，使用重复提供信号类。 使用场景二:可以设置capacity数量来限制缓存的value的数量,即只缓充最新的几个值。 RACSubject和RACReplaySubject简单使用: // RACSubject使用步骤// 1.创建信号 [RACSubject subject]，跟RACSiganl不一样，创建信号时没有block。// 2.订阅信号 - (RACDisposable *)subscribeNext:(void (^)(id x))nextBlock// 3.发送信号 sendNext:(id)value// RACSubject:底层实现和RACSignal不一样。// 1.调用subscribeNext订阅信号，只是把订阅者保存起来，并且订阅者的nextBlock已经赋值了。// 2.调用sendNext发送信号，遍历刚刚保存的所有订阅者，一个一个调用订阅者的nextBlock。// 1.创建信号RACSubject *subject = [RACSubject subject];// 2.订阅信号[subject subscribeNext:^(id x) &#123; // block调用时刻：当信号发出新值，就会调用. NSLog(@\"第一个订阅者%@\",x);&#125;];[subject subscribeNext:^(id x) &#123; // block调用时刻：当信号发出新值，就会调用. NSLog(@\"第二个订阅者%@\",x);&#125;];// 3.发送信号[subject sendNext:@\"1\"];// RACReplaySubject使用步骤:// 1.创建信号 [RACSubject subject]，跟RACSiganl不一样，创建信号时没有block。// 2.可以先订阅信号，也可以先发送信号。// 2.1 订阅信号 - (RACDisposable *)subscribeNext:(void (^)(id x))nextBlock// 2.2 发送信号 sendNext:(id)value// RACReplaySubject:底层实现和RACSubject不一样。// 1.调用sendNext发送信号，把值保存起来，然后遍历刚刚保存的所有订阅者，一个一个调用订阅者的nextBlock。// 2.调用subscribeNext订阅信号，遍历保存的所有值，一个一个调用订阅者的nextBlock// 如果想当一个信号被订阅，就重复播放之前所有值，需要先发送信号，在订阅信号。// 也就是先保存值，在订阅值。// 1.创建信号RACReplaySubject *replaySubject = [RACReplaySubject subject];// 2.发送信号[replaySubject sendNext:@1];[replaySubject sendNext:@2];// 3.订阅信号[replaySubject subscribeNext:^(id x) &#123; NSLog(@\"第一个订阅者接收到的数据%@\",x);&#125;];// 订阅信号[replaySubject subscribeNext:^(id x) &#123; NSLog(@\"第二个订阅者接收到的数据%@\",x);&#125;]; RACSubject替换代理 // 需求: // 1.给当前控制器添加一个按钮，modal到另一个控制器界面 // 2.另一个控制器view中有个按钮，点击按钮，通知当前控制器步骤一：在第二个控制器.h，添加一个RACSubject代替代理。@interface TwoViewController : UIViewController@property (nonatomic, strong) RACSubject *delegateSignal;@end步骤二：监听第二个控制器按钮点击@implementation TwoViewController- (IBAction)notice:(id)sender &#123; // 通知第一个控制器，告诉它，按钮被点了 // 通知代理 // 判断代理信号是否有值 if (self.delegateSignal) &#123; // 有值，才需要通知 [self.delegateSignal sendNext:nil]; &#125;&#125;@end步骤三：在第一个控制器中，监听跳转按钮，给第二个控制器的代理信号赋值，并且监听.@implementation OneViewController- (IBAction)btnClick:(id)sender &#123; // 创建第二个控制器 TwoViewController *twoVc = [[TwoViewController alloc] init]; // 设置代理信号 twoVc.delegateSignal = [RACSubject subject]; // 订阅代理信号 [twoVc.delegateSignal subscribeNext:^(id x) &#123; NSLog(@\"点击了通知按钮\"); &#125;]; // 跳转到第二个控制器 [self presentViewController:twoVc animated:YES completion:nil];&#125;@end RACTuple:元组类,类似NSArray,用来包装值. RACSequence:RAC中的集合类，用于代替NSArray,NSDictionary,可以使用它来快速遍历数组和字典。 使用场景：1.字典转模型 RACSequence和RACTuple简单使用 // 1.遍历数组 NSArray *numbers = @[@1,@2,@3,@4]; // 这里其实是三步 // 第一步: 把数组转换成集合RACSequence numbers.rac_sequence // 第二步: 把集合RACSequence转换RACSignal信号类,numbers.rac_sequence.signal // 第三步: 订阅信号，激活信号，会自动把集合中的所有值，遍历出来。 [numbers.rac_sequence.signal subscribeNext:^(id x) &#123; NSLog(@\"%@\",x); &#125;]; // 2.遍历字典,遍历出来的键值对会包装成RACTuple(元组对象) NSDictionary *dict = @&#123;@\"name\":@\"xmg\",@\"age\":@18&#125;; [dict.rac_sequence.signal subscribeNext:^(RACTuple *x) &#123; // 解包元组，会把元组的值，按顺序给参数里面的变量赋值 RACTupleUnpack(NSString *key,NSString *value) = x; // 相当于以下写法// NSString *key = x[0];// NSString *value = x[1]; NSLog(@\"%@ %@\",key,value); &#125;]; // 3.字典转模型 // 3.1 OC写法 NSString *filePath = [[NSBundle mainBundle] pathForResource:@\"flags.plist\" ofType:nil]; NSArray *dictArr = [NSArray arrayWithContentsOfFile:filePath]; NSMutableArray *items = [NSMutableArray array]; for (NSDictionary *dict in dictArr) &#123; FlagItem *item = [FlagItem flagWithDict:dict]; [items addObject:item]; &#125; // 3.2 RAC写法 NSString *filePath = [[NSBundle mainBundle] pathForResource:@\"flags.plist\" ofType:nil]; NSArray *dictArr = [NSArray arrayWithContentsOfFile:filePath]; NSMutableArray *flags = [NSMutableArray array]; _flags = flags; // rac_sequence注意点：调用subscribeNext，并不会马上执行nextBlock，而是会等一会。 [dictArr.rac_sequence.signal subscribeNext:^(id x) &#123; // 运用RAC遍历字典，x：字典 FlagItem *item = [FlagItem flagWithDict:x]; [flags addObject:item]; &#125;]; NSLog(@\"%@\", NSStringFromCGRect([UIScreen mainScreen].bounds)); // 3.3 RAC高级写法: NSString *filePath = [[NSBundle mainBundle] pathForResource:@\"flags.plist\" ofType:nil]; NSArray *dictArr = [NSArray arrayWithContentsOfFile:filePath]; // map:映射的意思，目的：把原始值value映射成一个新值 // array: 把集合转换成数组 // 底层实现：当信号被订阅，会遍历集合中的原始值，映射成新值，并且保存到新的数组里。 NSArray *flags = [[dictArr.rac_sequence map:^id(id value) &#123; return [FlagItem flagWithDict:value]; &#125;] array]; RACMulticastConnection:用于当一个信号，被多次订阅时，为了保证创建信号时，避免多次调用创建信号中的block，造成副作用，可以使用这个类处理。 使用注意:RACMulticastConnection通过RACSignal的-publish或者-muticast:方法创建. RACMulticastConnection简单使用: // RACMulticastConnection使用步骤: // 1.创建信号 + (RACSignal *)createSignal:(RACDisposable * (^)(id&lt;RACSubscriber&gt; subscriber))didSubscribe // 2.创建连接 RACMulticastConnection *connect = [signal publish]; // 3.订阅信号,注意：订阅的不在是之前的信号，而是连接的信号。 [connect.signal subscribeNext:nextBlock] // 4.连接 [connect connect] // RACMulticastConnection底层原理: // 1.创建connect，connect.sourceSignal -&gt; RACSignal(原始信号) connect.signal -&gt; RACSubject // 2.订阅connect.signal，会调用RACSubject的subscribeNext，创建订阅者，而且把订阅者保存起来，不会执行block。 // 3.[connect connect]内部会订阅RACSignal(原始信号)，并且订阅者是RACSubject // 3.1.订阅原始信号，就会调用原始信号中的didSubscribe // 3.2 didSubscribe，拿到订阅者调用sendNext，其实是调用RACSubject的sendNext // 4.RACSubject的sendNext,会遍历RACSubject所有订阅者发送信号。 // 4.1 因为刚刚第二步，都是在订阅RACSubject，因此会拿到第二步所有的订阅者，调用他们的nextBlock // 需求：假设在一个信号中发送请求，每次订阅一次都会发送请求，这样就会导致多次请求。 // 解决：使用RACMulticastConnection就能解决. // 1.创建请求信号RACSignal *signal = [RACSignal createSignal:^RACDisposable *(id&lt;RACSubscriber&gt; subscriber) &#123; NSLog(@\"发送请求\"); return nil; &#125;]; // 2.订阅信号 [signal subscribeNext:^(id x) &#123; NSLog(@\"接收数据\"); &#125;]; // 2.订阅信号 [signal subscribeNext:^(id x) &#123; NSLog(@\"接收数据\"); &#125;]; // 3.运行结果，会执行两遍发送请求，也就是每次订阅都会发送一次请求 // RACMulticastConnection:解决重复请求问题 // 1.创建信号 RACSignal *signal = [RACSignal createSignal:^RACDisposable *(id&lt;RACSubscriber&gt; subscriber) &#123; NSLog(@\"发送请求\"); [subscriber sendNext:@1]; return nil; &#125;]; // 2.创建连接 RACMulticastConnection *connect = [signal publish]; // 3.订阅信号， // 注意：订阅信号，也不能激活信号，只是保存订阅者到数组，必须通过连接,当调用连接，就会一次性调用所有订阅者的sendNext: [connect.signal subscribeNext:^(id x) &#123; NSLog(@\"订阅者一信号\"); &#125;]; [connect.signal subscribeNext:^(id x) &#123; NSLog(@\"订阅者二信号\"); &#125;]; // 4.连接,激活信号 [connect connect]; RACCommand:RAC中用于处理事件的类，可以把事件如何处理,事件中的数据如何传递，包装到这个类中，他可以很方便的监控事件的执行过程。 使用场景:监听按钮点击，网络请求 RACCommand简单使用 // 一、RACCommand使用步骤: // 1.创建命令 initWithSignalBlock:(RACSignal * (^)(id input))signalBlock // 2.在signalBlock中，创建RACSignal，并且作为signalBlock的返回值 // 3.执行命令 - (RACSignal *)execute:(id)input // 二、RACCommand使用注意: // 1.signalBlock必须要返回一个信号，不能传nil. // 2.如果不想要传递信号，直接创建空的信号[RACSignal empty]; // 3.RACCommand中信号如果数据传递完，必须调用[subscriber sendCompleted]，这时命令才会执行完毕，否则永远处于执行中。 // 三、RACCommand设计思想：内部signalBlock为什么要返回一个信号，这个信号有什么用。 // 1.在RAC开发中，通常会把网络请求封装到RACCommand，直接执行某个RACCommand就能发送请求。 // 2.当RACCommand内部请求到数据的时候，需要把请求的数据传递给外界，这时候就需要通过signalBlock返回的信号传递了。 // 四、如何拿到RACCommand中返回信号发出的数据。 // 1.RACCommand有个执行信号源executionSignals，这个是signal of signals(信号的信号),意思是信号发出的数据是信号，不是普通的类型。 // 2.订阅executionSignals就能拿到RACCommand中返回的信号，然后订阅signalBlock返回的信号，就能获取发出的值。 // 五、监听当前命令是否正在执行executing // 六、使用场景,监听按钮点击，网络请求// 1.创建命令 RACCommand *command = [[RACCommand alloc] initWithSignalBlock:^RACSignal *(id input) &#123; NSLog(@\"执行命令\"); // 创建空信号,必须返回信号 // return [RACSignal empty]; // 2.创建信号,用来传递数据 return [RACSignal createSignal:^RACDisposable *(id&lt;RACSubscriber&gt; subscriber) &#123; [subscriber sendNext:@\"请求数据\"]; // 注意：数据传递完，最好调用sendCompleted，这时命令才执行完毕。 [subscriber sendCompleted]; return nil; &#125;]; &#125;]; // 强引用命令，不要被销毁，否则接收不到数据 _conmmand = command; // 3.执行命令 [self.conmmand execute:@1]; // 4.订阅RACCommand中的信号 [command.executionSignals subscribeNext:^(id x) &#123; [x subscribeNext:^(id x) &#123; NSLog(@\"%@\",x); &#125;]; &#125;]; // RAC高级用法 // switchToLatest:用于signal of signals，获取signal of signals发出的最新信号,也就是可以直接拿到RACCommand中的信号 [command.executionSignals.switchToLatest subscribeNext:^(id x) &#123; NSLog(@\"%@\",x); &#125;]; // 5.监听命令是否执行完毕,默认会来一次，可以直接跳过，skip表示跳过第一次信号。 [[command.executing skip:1] subscribeNext:^(id x) &#123; if ([x boolValue] == YES) &#123; // 正在执行 NSLog(@\"正在执行\"); &#125;else&#123; // 执行完成 NSLog(@\"执行完成\"); &#125; &#125;]; RACScheduler:RAC中的队列，用GCD封装的。 RACUnit :表⽰stream不包含有意义的值,也就是看到这个，可以直接理解为nil. RACEvent: 把数据包装成信号事件(signal event)。它主要通过RACSignal的-materialize来使用，然并卵。 7.ReactiveCocoa开发中常见用法。7.1 代替代理: rac_signalForSelector：用于替代代理。 7.2 代替KVO : rac_valuesAndChangesForKeyPath：用于监听某个对象的属性改变。 7.3 监听事件: rac_signalForControlEvents：用于监听某个事件。 7.4 代替通知: rac_addObserverForName:用于监听某个通知。 7.5 监听文本框文字改变: rac_textSignal:只要文本框发出改变就会发出这个信号。 7.6 处理当界面有多次请求时，需要都获取到数据时，才能展示界面 rac_liftSelector:withSignalsFromArray:Signals:当传入的Signals(信号数组)，每一个signal都至少sendNext过一次，就会去触发第一个selector参数的方法。 使用注意：几个信号，参数一的方法就几个参数，每个参数对应信号发出的数据。 7.7 代码演示 // 1.代替代理 // 需求：自定义redView,监听红色view中按钮点击 // 之前都是需要通过代理监听，给红色View添加一个代理属性，点击按钮的时候，通知代理做事情 // rac_signalForSelector:把调用某个对象的方法的信息转换成信号，就要调用这个方法，就会发送信号。 // 这里表示只要redV调用btnClick:,就会发出信号，订阅就好了。 [[redV rac_signalForSelector:@selector(btnClick:)] subscribeNext:^(id x) &#123; NSLog(@\"点击红色按钮\"); &#125;]; // 2.KVO // 把监听redV的center属性改变转换成信号，只要值改变就会发送信号 // observer:可以传入nil [[redV rac_valuesAndChangesForKeyPath:@\"center\" options:NSKeyValueObservingOptionNew observer:nil] subscribeNext:^(id x) &#123; NSLog(@\"%@\",x); &#125;]; // 3.监听事件 // 把按钮点击事件转换为信号，点击按钮，就会发送信号 [[self.btn rac_signalForControlEvents:UIControlEventTouchUpInside] subscribeNext:^(id x) &#123; NSLog(@\"按钮被点击了\"); &#125;]; // 4.代替通知 // 把监听到的通知转换信号 [[[NSNotificationCenter defaultCenter] rac_addObserverForName:UIKeyboardWillShowNotification object:nil] subscribeNext:^(id x) &#123; NSLog(@\"键盘弹出\"); &#125;]; // 5.监听文本框的文字改变 [_textField.rac_textSignal subscribeNext:^(id x) &#123; NSLog(@\"文字改变了%@\",x); &#125;]; // 6.处理多个请求，都返回结果的时候，统一做处理. RACSignal *request1 = [RACSignal createSignal:^RACDisposable *(id&lt;RACSubscriber&gt; subscriber) &#123; // 发送请求1 [subscriber sendNext:@\"发送请求1\"]; return nil; &#125;]; RACSignal *request2 = [RACSignal createSignal:^RACDisposable *(id&lt;RACSubscriber&gt; subscriber) &#123; // 发送请求2 [subscriber sendNext:@\"发送请求2\"]; return nil; &#125;]; // 使用注意：几个信号，参数一的方法就几个参数，每个参数对应信号发出的数据。 [self rac_liftSelector:@selector(updateUIWithR1:r2:) withSignalsFromArray:@[request1,request2]];&#125;// 更新UI- (void)updateUIWithR1:(id)data r2:(id)data1&#123; NSLog(@\"更新UI%@ %@\",data,data1);&#125; 8.ReactiveCocoa常见宏。8.1 RAC(TARGET, [KEYPATH, [NIL_VALUE]]):用于给某个对象的某个属性绑定。 基本用法 // 只要文本框文字改变，就会修改label的文字 RAC(self.labelView,text) = _textField.rac_textSignal; 8.2 RACObserve(self, name):监听某个对象的某个属性,返回的是信号。 基本用法 [RACObserve(self.view, center) subscribeNext:^(id x) &#123; NSLog(@\"%@\",x); &#125;]; 8.3 @weakify(Obj)和@strongify(Obj),一般两个都是配套使用,解决循环引用问题. @weakify(self);RACSignal *signal = [RACSignal createSignal:^RACDisposable *(id&lt;RACSubscriber&gt; subscriber) &#123; @strongify(self) NSLog(@\"%@\",self); return nil;&#125;]; 8.4 RACTuplePack：把数据包装成RACTuple（元组类） 基本用法// 把参数中的数据包装成元组 RACTuple *tuple = RACTuplePack(@10,@20); 8.5 RACTupleUnpack：把RACTuple（元组类）解包成对应的数据。 基本用法// 把参数中的数据包装成元组 RACTuple *tuple = RACTuplePack(@\"xmg\",@20); // 解包元组，会把元组的值，按顺序给参数里面的变量赋值 // name = @\"xmg\" age = @20 RACTupleUnpack(NSString *name,NSNumber *age) = tuple;","categories":[{"name":"iOS","slug":"iOS","permalink":"http://www.calm1993.com/categories/iOS/"}],"tags":[{"name":"ReactiveCocoa","slug":"ReactiveCocoa","permalink":"http://www.calm1993.com/tags/ReactiveCocoa/"}]},{"title":"Python 开发工具安装","slug":"python/Python 开发工具安装","date":"2017-11-14T03:39:38.000Z","updated":"2017-11-14T03:45:34.000Z","comments":true,"path":"post/python/Python 开发工具安装.html","link":"","permalink":"http://www.calm1993.com/post/python/Python 开发工具安装.html","excerpt":"PyCharm 下载链接：【PyCharm】 Python 3.x 最新版安装教程：brew install python3brew linkappsexport PATH=/usr/local/bin:$PATHsource ~/.bash_profilepython3 --version 最佳推荐 Python 开发工具，使用 PyCharm，附上 PyCharm 2017 最新激活链接： PyCharm 2017 最新激活链接","text":"PyCharm 下载链接：【PyCharm】 Python 3.x 最新版安装教程：brew install python3brew linkappsexport PATH=/usr/local/bin:$PATHsource ~/.bash_profilepython3 --version 最佳推荐 Python 开发工具，使用 PyCharm，附上 PyCharm 2017 最新激活链接： PyCharm 2017 最新激活链接","categories":[{"name":"python","slug":"python","permalink":"http://www.calm1993.com/categories/python/"}],"tags":[{"name":"python工具","slug":"python工具","permalink":"http://www.calm1993.com/tags/python工具/"}]},{"title":"mac连上wifi,上网慢卡,打不开appStore问题","slug":"Mac/mac连上wifi,上网慢卡","date":"2017-10-18T01:55:38.000Z","updated":"2017-10-18T02:00:48.000Z","comments":true,"path":"post/Mac/mac连上wifi,上网慢卡.html","link":"","permalink":"http://www.calm1993.com/post/Mac/mac连上wifi,上网慢卡.html","excerpt":"今天拿出好久没用的mac发现有好多软件可以更新，于是乎，打开 Mac App Store ，显示无法连接,请重试,然后发现软件能上网,Safari上网慢 ,要么就是打不开网页。 上网查了半天，猜测到可能是用代理导致的。由于众所周知的原因，为了方便查询资料，我就在香港弄了一个服务器，提供一个 SOCKS 代理来用。苹果官方论坛中也有提到 哇皮嗯、代理会影响。 然后，去掉代理，依然不行。重启，依然不行，换 DNS 依然不行。 据说和钥匙串有关系，于是乎，修复钥匙串，删除 crls 的缓存，去掉代理，就 OK 了。 修复钥匙串。打开“钥匙串访问”应用，然后菜单“钥匙串访问” &gt; “钥匙串急救”，进行修复，果然发现几个有问题的项目 删除 crls 的缓存。在 Finder command+shift+G 或者命令行前往 “/var/db/crls/”，删除 几个文件：crlcache.db,crlcache2.db 和 ocspcache.db 去掉代理然后重启，然后就好了。","text":"今天拿出好久没用的mac发现有好多软件可以更新，于是乎，打开 Mac App Store ，显示无法连接,请重试,然后发现软件能上网,Safari上网慢 ,要么就是打不开网页。 上网查了半天，猜测到可能是用代理导致的。由于众所周知的原因，为了方便查询资料，我就在香港弄了一个服务器，提供一个 SOCKS 代理来用。苹果官方论坛中也有提到 哇皮嗯、代理会影响。 然后，去掉代理，依然不行。重启，依然不行，换 DNS 依然不行。 据说和钥匙串有关系，于是乎，修复钥匙串，删除 crls 的缓存，去掉代理，就 OK 了。 修复钥匙串。打开“钥匙串访问”应用，然后菜单“钥匙串访问” &gt; “钥匙串急救”，进行修复，果然发现几个有问题的项目 删除 crls 的缓存。在 Finder command+shift+G 或者命令行前往 “/var/db/crls/”，删除 几个文件：crlcache.db,crlcache2.db 和 ocspcache.db 去掉代理然后重启，然后就好了。","categories":[{"name":"Mac","slug":"Mac","permalink":"http://www.calm1993.com/categories/Mac/"}],"tags":[{"name":"Mac","slug":"Mac","permalink":"http://www.calm1993.com/tags/Mac/"}]},{"title":"关于Xcode9的坑","slug":"iOS11/关于Xcode9的坑","date":"2017-09-25T05:50:38.000Z","updated":"2019-02-18T05:54:58.000Z","comments":true,"path":"post/iOS11/关于Xcode9的坑.html","link":"","permalink":"http://www.calm1993.com/post/iOS11/关于Xcode9的坑.html","excerpt":"Xcode9的添加图片的坑 最近更新了Xcode9,在做项目迭代的时候发现图片拖进项目加载不出来.苹果爸爸这又是在搞事情啊,经过一番折腾后终于发现原因了.","text":"Xcode9的添加图片的坑 最近更新了Xcode9,在做项目迭代的时候发现图片拖进项目加载不出来.苹果爸爸这又是在搞事情啊,经过一番折腾后终于发现原因了. 示例 运行结果: 图片加载不出来的原因图片加载不出来的原因是因为Xcode9图片直接拖进项目,并没有将图片真正的放进项目. 检查一下项目资源文件,原来我们的图片根本没有添加进来. 假如我们把TagetMembership的对勾勾上呢 B一下,就会发现项目报错了 但是项目还是能运行起来,还是没有图片.后来我又尝试直接把图片放进了\bAssets.xcassets蓝色文件夹里面 运行项目,图片\b出来了 jpg格式图片后面\b我又对jpg格式的图片尝试添加项目,然后把对勾打上. 运行项目 没有问题,可以加载出图片 后来我又发现jpg格式图片通过Add Files to这种方式也是可以正常添加图片的 查看一下图片资源 所以如果是jpg格式图片大可以通过Add Files to这种方式添加,png图片则需要添加到\bAssets.xcassets蓝色文件夹里面.拖拽方式拖不进去这确实是一个坑,对于png格式图片苹果更加严格限制开发者的存放位置.也是为了app图片资源的安全性着想. 举一反三 既然图片资源是这样,那么其他资源文件呢,例如json文件,音频,文件,(.h.m)文件,是不是应该也是这样.","categories":[{"name":"iOS","slug":"iOS","permalink":"http://www.calm1993.com/categories/iOS/"}],"tags":[{"name":"iOS 11","slug":"iOS-11","permalink":"http://www.calm1993.com/tags/iOS-11/"}]},{"title":"程序员需要看什么书","slug":"程序员需要看什么书","date":"2017-08-11T08:18:12.000Z","updated":"2017-08-11T08:20:58.000Z","comments":true,"path":"post/程序员需要看什么书.html","link":"","permalink":"http://www.calm1993.com/post/程序员需要看什么书.html","excerpt":"","text":"做程序员，要看什么书?&emsp;&emsp;第一阶段: 《程序员的修炼之道–从小工到专家》 &emsp;&emsp;第二阶段: 《莫生气》《圣经》《老子》《轮持久战》 &emsp;&emsp;第三阶段: 《颈椎病康复指南》《腰椎间盘突出日常护理》《心脏病的预防与治疗》《高血压降压宝典》《强迫症的自我恢复》《精神病症状学》 &emsp;&emsp;第四阶段: 《活着》 每一个程序猿都不容易,大家珍惜身体.","categories":[],"tags":[]},{"title":"如何正确看待Swift","slug":"Swift/如何正确看待Swift","date":"2017-08-11T06:12:59.000Z","updated":"2019-02-18T05:32:10.000Z","comments":true,"path":"post/Swift/如何正确看待Swift.html","link":"","permalink":"http://www.calm1993.com/post/Swift/如何正确看待Swift.html","excerpt":"原文 【硅谷问道】Chris Lattner 访谈录 话题 Chris Lattner 是谁？ Xcode 的编译器 LLVM 背后有怎样的故事？ Swift 诞生的前世今生，封闭的苹果为何要拥抱开源？ 说好的 ABI 稳定性何时能推出？ Chris Lattner 是谁","text":"原文 【硅谷问道】Chris Lattner 访谈录 话题 Chris Lattner 是谁？ Xcode 的编译器 LLVM 背后有怎样的故事？ Swift 诞生的前世今生，封闭的苹果为何要拥抱开源？ 说好的 ABI 稳定性何时能推出？ Chris Lattner 是谁 教育背景 伊利诺伊大学 PHD 工作经历 2005年 - 2017年供职苹果，前开发部高级总监，架构师 2017年开始，担任特斯拉副总裁，负责自动驾驶 主要成就 Swift 之父，主要作者 LLVM 之父，主要作者 Clang 主要贡献者 荣誉 2013年获得 ACM 系统设计大奖 2016年被评为“创造未来的25位当世天才” 访谈实录自我介绍1. 你怎么看待自己？ 我是个程序员。我喜欢写代码。我编程有很长时间了。 我在读博的时候就开始写 LLVM 了。当时 LLVM 是我的博士研究项目，我想把它做成工业界中颠覆性的产品。当时我异想天开，尝试了各种架构设计，想解决以往编译器所有的弊端 – 结果当然没有如愿。我毕业后，就希望能接着搞 LLVM ，当时只有苹果允许我入职之后继续设计并实现 LLVM 。我想都没想就加入了苹果。 LLVM 2. 说说 LLVM（Low Level Virtual Machine）到底是什么吧 先说编译器：编译器是把程序员的代码翻译成机器可以理解的语言的工具； 再谈 LLVM：一个模块化和可重用的编译器和工具链技术的集合，Clang 是 LLVM 的子项目，是 C，C++ 和 Objective-C 编译器，因为多模块的复用，所以提供了惊人的快速编译，比 GCC 快3倍。 3.LLVM是一开始就作为一个完整的编译工具来使用的吗？还是有什么其他故事 LLVM 当时是为了解决一个小问题而开发的：当使用OpenGL 函数库的时候（Mac OS 10.4 和 10.5环境下），比如你要调用这个函数，glVertex3f()，编译器必须将其转化为特定的GPU可以理解的数据。但是这带来一个问题：市面上有海量的GPU，每个GPU的性能和参数也不尽相同，所要求的数据格式也不同。这时 LLVM 可以产生很小的一部分代码去解决这个问题，这是 LLVM 诞生的初衷。 4. LLVM 的 bytecode 和 Apple 现在的 bitcode 有什么不同？ 这是历史遗留问题。一开始 LLVM 是开源的，所有代码在转成二进制时就叫做 bytecode – 因为 java 当年就是这么叫的。当时这一部分有很多问题：比如不能扩展，无法兼容，非常脆弱 然后就到了 LLVM 2.0，当时我重新设计了架构，采用的就是 Bitcode 机制。LLVM 2.0 将所有代码以比特流(bit stream)而不是字节流(byte stream)的形式来编码。这就是 bitcode 这一术语的由来。 主要的工作流程就是现将代码转成比特流，然后相应处理。处理完后再将编码传到其他地方去。 5. Bitcode 这个机制比直接传输二进制有什么好处 好处那是多了去了。首先 编译器工作起来会越来越好。因为通过Bitcode机制，它可以通过编译不同代码来存储各种优化方法，这样下次碰到类似代码，它就会自动启动相关优化机制，使得效率提升。还有个好处是 LLVM 可以让芯片的兼容性变得很好。因为 Apple 每年都在芯片上推陈出新，它们转化为二进制的规则都不尽相同，LLVM 只要每次重新编码并传输成比特流就好了。 当然 Bitcode 也不是万能的。比如它不能解决 32位的 APP 在64位机器上的兼容问题。这个问题其实应该依靠代码逻辑。 谈管理6. 在职业生涯中，你在 LLVM上鞠躬尽瘁，但我们发现这几年你更多的工作是在管理上，你自己怎么看这种转变的？ 我虽然做管理了，但是我依然喜欢写代码，而且我每天都写，因为我就是个极客嘛。而且，其实我很早就开始做管理的工作了。不过我一直是作为技术领导人的角色带 2 到 3 个人的，我只是在写代码方面把把关，给他们提提建议这样。 后来带的人多了，队伍也大了。我不仅管程序员，还管小组经理和其他技术领导人。虽然我一直喜欢写代码，但是管理对我来说是一个必须要去做的事。现在回过头来，我觉得干得还不错。跟大家一起工作之后我知道很多事协同工作效果更好，和同事交流你就会理解他们的想法，这样我就可以制定更好的计划路线。 其实我没感觉整个过程有什么不同。直到今天我还夜以继日、废寝忘食得写代码，我并不是坐那边动动嘴皮子，指挥别人干活的老板。我其实每个周末都在写代码，我很忙的。 Swift7. Swift 是如何诞生的？在苹果这样一个大厂，决定做出如此巨大的变革，同时还是在封闭的环境下，你是如何一步步实现的？ 首先，苹果内部所有的项目都不尽相同 – 工作流程、战略规划、实施细节，到最后发布。Swift 也一样，没有可比性。因为苹果本身就是小组单兵作战模式 – 每个组负责不同的大方向，组里自己计划和工作，甚至招人都是各自招。 言归正传，契机发生在2010年了。当时好像是我们刚刚完成了 Clang 对 C++的支持。你也知道 C++ 写起来有多丑，但是做个编辑器支持 C++，完善 C++ 这门语言就是另一回事了，我们当时搞了好久终于完成的时候特别有成就感。当然 Clang 远没有到达完美的地步。 我又扯远了。除了做 Clang 以外，无论是 C语言，C++，还是 Objective-C，都有一些我不是很满意的地方。所以我就想要不我们搞个新的语言来吧。新的语言要越简单越好。一开始大家都没认真，后来我跟很多同事聊了之后觉得新语言的计划可行，而且大家都很亦可赛艇。于是我们就用业余时间开始顶层设计和写代码。 现在问题来了，因为我们已经有 Objective-C 了。虽然它有几个地方很丑，比如老是用 “@”，每句结束了还要打分号，但是这些并不妨碍它是一门伟大的语言。所以，我们为什么要开发新语言，而不是把精力花在优化 Objective - C 上？ 原因有三。 第一，如果我们大幅优化 Objective - C，把很多 Swift 的特性加进去，这对开发者来说是灾难性的，因为他们要对原来的 APP 要进行大幅修改； 第二，Objective - C 很多特性积重难返，比如它安全性上的问题； 第三，Objective - C 是基于 C 开发的语言，所以你无论怎么优化，它必然有 C 语言自身的缺陷。 于是我们就动手做 Swift 了，它的背后有着数百人的努力: 支持 Xcode，开发 Playground，兼容调试器和编译器。我个人感到最骄傲的一点是，我们并不打算自己内部把它做到完美 – 我们开源、我们依靠社区，这样一门语言才能在无数开发者的实战中得到检验和改进，我想这才是 Swift 最棒的地方。 8. 你之前在优化 Objective-C 的时候，有没有想到什么地方是未来 Swift 可以用得到的？ ARC。我们其实一直都在争论是用垃圾回收机制（garbage collection）还是 ARC，后来决定了是 ARC。 另一个是模块化，我们也将这一部分的经验带到了 Swift 开发中。 其实，很多数组和字典方面的语法优化本来是计划在 Objective - C 上面的。但是后来我们开发了 Swift，于是这些改进被直接用在了新语言上，所以大家会在写 Swift 的时候觉得似曾相识，因为本来这些就是 Objective-C 的升级版本嘛。 我可以透露一个有意思的事情。我们在做 Swift 的时候，很多 iOS 开发者，包括苹果内部的工程师，都在吐槽我们这几年在 Objective - C 上毫无建树，都在说你们为什么不做这个那个。我们当然不能告诉他们我们在全力开发 Swift，而他们所要的语法功能我们都会给。 9. 苹果内部对于 Swift 的使用情况和开发是怎么看得？ Swift 团队对于开发上有明确的目标和计划，应用二进制接口（ABI）的稳定性一直是我们的首要目标。很多人很喜欢我们开源的 Swift Playground。同时 iOS 系统内置的 Music App 也是 Swift 写的。其实用不用 Swift 主要是技术和开发方面的考量，苹果内部同时得兼顾稳定性和开发效率，这不是说大家喜不喜欢这个语言的问题。 Swift 刚发布的时候，内部很多组都很惊讶：我们已经有了 Objective-C，为什么还要搞新的 Swift？而且 Objective-C 本身就很不错，开发起来也很顺手。后来渐渐 Swift 成熟了，大家也爱上了这个新生儿。 内部其实对于 Swift 一个很大的顾虑在于，苹果的所有开发必须兼容32位机器，而32位的应用都采用了 Objective-C 的 runtime 机制。这就要求 Swift 团队也弄出个类似的机制，或者弄个兼容的方案，否则 Swift 无法与 AppKit 适配。 10. 开源后的 Swift 发展态势喜人，你对此有什么看法？ 开源之后，Swift 发展之好让我咋舌，然而这也是问题所在。 当年我们开源了 LLVM 和 Clang，它们也发展喜人。我们的对手 AMD 们完全跟不上我们。但是跟 Swift 比起来，它们的发展也太慢了，LLVM 和 Clang 开源后完全没有 Swift 这么火。 Swift 就不同了，开源一年之后，我们就有了上百万的开发者在使用这门语言 – 我和很多有丰富开源经验的老工程师都吓了一跳，这简直了！然后我们每天收到无数的邮件和 pull requests，要求更新这个、要求优化那个，我们的节奏完全被打乱了。我们如何规划开发？我们如何把 Swift 的开发导向一个正确的方向？这些问题随着时间的推移和经验的积累，慢慢找到了解决之道。 我现在觉得开源这个决定至关重要。一来大家会帮着优化；二来我们有个巨大的论坛，在那里大家可以畅所欲言，全世界的人都在帮着 Swift 进步，这真的很棒。我们虽然没有一开始就具体计划要开源，但是苹果内部当时都觉得 Swift 肯定有一天要开源。 苹果与特斯拉 11. 苹果好像一直是个封闭的公司，你们内部对于开源怎么看？ 苹果其实有开源的传统。 LLVM 虽然不是始于苹果，但是最终是苹果完成并将其开源。Clang 则完完全全是生于斯开源于斯。还有其他工具，比如 LLDB，libc+，以及compiler-rt 都是如此。 所以对于 Swift 来说，开源只是时间问题。当年从 Swift 1.0 到 Swift 2.0，一切都乱七八糟。当时我们重点在开发错误处理机制，还有协议、拓展等一系列重要的功能。所以开源 Swift 1.0，并不是一个好选择，因为这些重要的东西都没有，而这些开发是当务之急。当 Swift 2.0 到来的时候，我们才有空去开源、去做社区拓展和论坛搭建。开源社区可以帮我们修复细节，我们这时候可以更多的投入在架构设计上。 12. 苹果最让你怀念的是什么？ 苹果是这样一个公司，你可以选择你喜欢的东西，然后努力工作去实现它，最终你的工作会落实在产品上，影响亿万计的人。 有很多公司，你可以努力工作，但是不一定能做你喜欢的东西；你做出来东西，可能会被束之高阁；你做的产品，也许最后很幸运的发布，但是并不一定有很多人会用。在苹果，你的工作可以真正改变世界，很有成就感。 13. 你觉得到特斯拉之后，还会努力为 Swift 做出贡献吗？ 特斯拉的工作非常有挑战性，这是我最开心的地方。我现在还没入职，所以也不知道我之后对 Swift 能做多少工作。也许我还会夜以继日的发 Pull Request，也许我就周末写写 Swift 代码。我应该会从各个方面 – 无论是顶层设计还是具体代码实现，与苹果的核心团队合作，为这个语言做贡献。 其实我一直想说，Swift 只是我在苹果工作的一小部分，我花了大量的时间在其他事情上。实际上在苹果我也就晚上或者周末有空写写 Swift。我希望到了特斯拉之后我还能花同样的精力和时间在 Swift 上，毕竟我对这门语言统治世界充满期待。 ABI 稳定性14. 现在 Swift 已经到了第3个版本了。我们也知道ABI稳定性的追求一直是你们的目标，但是它也一直被各种事情拖延。你对此有什么计划吗？或者说你从拖延中学到了什么经验教训吗？ ABI 推迟有两个原因。 第一是因为 Swift 的开发进程中有很多不确定性。当 Swift 开源之时，一堆人对我们提 pull request，提各种各样的 issue。这样我们就不得不去花大量的时间去维护开源社区，而不是专心去做计划内的工作。 第二个原因是，尽管稳定的 ABI 很重要，但是对于开发者来说，稳定的 ABI 对他们来说没有明显的好处，他们更关心是语法和兼容上的稳定和优化。所以我们后来修改了计划，语法和兼容上的稳定性被定为是最先要实现的目标。这样当 Swift 3.1 或者 Swift 4.0 出来的时候，大家不用担心语言上的转化会让 Xcode 崩溃，或是需要大家整个重构 APP。Swift 3.0 主要就是实现这个目标。 15. 稳定的 ABI 什么时候推出？他会赶在异步和并发模型之前吗？ Swift 现有的内存管理机制对 ABI 稳定性造成了不小的影响。有些底层逻辑还需要调整，比如 getter 和 setter 的生成以及属性的内存分配问题，苹果内部正在做这件事，这之后我们才能完成 ABI。至于并发模型啥的就跟 ABI 没有关系了。 很多人担心 Swift 4.0 的时候苹果能不能推出稳定的 ABI，因为毕竟工作量太大。ABI 的工作正在井然有序得进行，而且对于开源社区来讲推出稳定的 ABI 至关重要。Ted （Chris Lattner 之后的 Swift 领导人）有一件事说对了，现在 Swift 当务之急就是让编译器更稳定，让错误处理更方便，提高编译速度，并且将 Swift 拓展到大规模系统中。 我在想 Swift 4.0 的时候究竟能看到什么。也许没有稳定的 ABI，但是一定会有重要的新功能加入。 ABI 将允许未来 Swift 版本开发的应用程序和编译库可以在二进制层次上与 Swift 3.0 版本的应用程序和编译库相互调用。这样，ABI的稳定性将保证一定程度的二进制兼容性，并且第三方更容易发布二进制库。另外，ABI 将允许删除需要的 Swift 标准库和二进制文件，就像目前情况下通过Xcode创建的 iOS 和 OS X 应用程序一样。 补充 LLVM的三层结构 第一层：Clang 编译器，负责编译各种语言 第二层：代码优化器，通过模块化操作优化代码，是 Bitcode 逻辑的主要部分 第三层：代码翻译器，针对不同平台和 GPU 将代码翻译成机器语言 补充：LLDB，llbc++，compile rt LLDB: 一个有着 REPL 的特性和 C++ ,Python 插件的开源调试器。LLDB 绑定在 Xcode 内部，存在于主窗口底部的控制台中； libc++，libc++ ABI: 高性能 C++ 标准库实现，支持 C++ 11 compiler-rt：为 LLVM 和 Clang 设计的编译器扩展函数库。针对 __fixunsdfdi 和其他目标机器上没有一个核心 IR (intermediate representation) 对应的短原生指令序列时，提供高度调优过的底层代码生成支持。 ABI 是什么？ Application Binary Interface，中文名：应用二进制接口。是 APP 和 操作系统、其他应用之间的二进制接口。它包括以下细节： 数据类型的大小、布局和对齐; 调用约定（控制着函数的参数如何传送以及如何接受返回值），例如，是所有的参数都通过栈传递，还是部分参数通过寄存器传递；哪个寄存器用于哪个函数参数；通过栈传递的第一个函数参数是最先push到栈上还是最后； 系统调用的编码和一个应用如何向操作系统进行系统调用； 以及在一个完整的操作系统ABI中，目标文件的二进制格式、程序库等等。 (下) 话题 Swift 在 Server 和操作系统方面有着怎样的雄心抱负？ Swift 与 Objective-C 的爱恨情仇？ Swift 之父对于 RxSwift 和 ARC 有什么独到的见解？ 随着 Swift 之父的出走，这门语言还会继续高歌猛进吗？ 访谈实录Swift 在系统、服务器、网页端的发展16. Swift 在服务器，或者 Linux 上可以说运行得不错。你们是一开始就计划在服务器或者系统端运行 Swift，还是说你们更希望 Swift 专注于 iOS 开发，而不是去与 python 或 Rails 竞争？ 你如果去看苹果官方的 Swift 书，里面有这样一句：Swift 的目标是，上能写应用程序，下能写操作系统（Swift was designed to scale from hello world to an entire operating system）。所以我们一开始，就是要将它创作成为一门一统天下的语言。 这也许有点痴人说梦，但是大家等着，过几年就知道了。无论是我还是苹果的其他人，都把 Swift 当成是未来世界的主流语言来看的，它将会超越 Python，甚至有一天取代 C。那么我们是怎么实现这一步的呢？ 开源是重要的一环。你不开源，别的平台就不大想用这个语言。当各种各样的开发都采用 Swift ，Swift 一统天下的目标也就越来越现实。现在很多学校的计算机基础教育就在教 Swift，它越来越流行了。 所以嘛，第一步我们就是让这个语言流行起来，让大家使用它。我对“流行”的定义是，Swift 必须要有一个杀手级的产品，这样大家就会知道 Swift 有多好，大家都会使用它。现在 iOS 平台和 Mac OS 平台有很多非常棒的 Swift 应用。这样我们开始第二步，开源。第三步，我们要走得更远。 什么叫走得更远？我觉得现在我们要做的就是把 Swift 应用到服务器端。其实服务器和移动应用开发颇有类似，比如架构设计和函数库调用上。但是，唯一的麻烦就是我们得让 Swift 能在 Lunix 上流畅运行。同时构建大量服务器端的库函数。现在 Swift.org 上已经有专门的版块讨论服务器端上的开发了，大家集思广益的感觉非常好。 再接下来，Swift 要取代 Java，无论是脚本语言还是底层的系统设计，Swift 最终都应该能应付自如。 脚本语言上，开源社区和我们苹果内部都在尝试将正则表达式、多行字符串等脚本语言的特征都加入到 Swift 当中，虽然工作量很大，但我认为它们最终都将成为 Swift 的一个部分。 系统开发方面，我觉得取代 Java 最重要的一点就是 Swift 一定要有自己的特色。我觉得 Rust 是一个不错的语言，虽然现在没多少人用。Swift 在某些顶层开发上要明显优于 Rust。再等过些年，当 Swift 在系统开发上真正流行起来之时，Swift 就离一统天下不远了。 17. 对于 Swift 在服务器上的发展，你觉得交给开源社区去做就足够了吗？苹果自己会不会推出面向服务器端的 Swift 函数库？ 首先我觉得若要成为服务器端的流行语言，这几个部分 Swift 必须具备：编码和解码，网络传输协议，HTTP。这些部分我觉得要成为标准函数库，因为它们是最基本的东西，苹果内部自己来做也许更好，因为能确保质量。对于具体的网络应用函数库，我觉得短期内没必要。这是因为业界内部对此就争议很大，如同 Ruby on Rails 那样的王者框架还没有出现。 我觉得对开源社区而言，最重要是两个工作。第一，是 Swift 的包管理器（Package Manager）。这个可以让我们在多个平台、不同函数库之间协同工作，大幅提高兼容性和效率；第二，是并发模型（Concurrency Model）。Go 语言之所以在服务器和云端开发这么受欢迎，就是因为并发模型做得好。并发模型应该会集成在 Swift 5 中。 18. 现在 Swift 在服务器端还不是那么成熟。有人说 Swift 不过是写 App 的一门语言。现在已经 3.0 版本了，大家貌似都还只是将 Swift 用来写写 iOS 应用。你怎么看？ 我现在根本不担心 Swift 在服务器端最后不会成功。很多人写了几年 Swift，自以为很懂这门语言。当 Swift 具备服务器端特性的时候，苹果一定会跟大家说，你看 Swift 能做这个那个，你用其他语言来写就要麻烦得多。 现在最大的问题是大家还觉得 Swift 只是苹果自己搞出来的东西。他们觉得 Swift 不过是苹果自己的玩具，只能用在苹果自己的 iOS 系统和 Mac OS 系统上。所以我们应该加大开源和构建社区的力度。现在外行对于 Swift 的态度还可以接受，慢慢地 Swift 就会在系统开发领域追上来。 19. 大家似乎都在期待 Swift 能在网页开发上有所建树。现在网页或者网络程序开发方面，一般是多种语言混用，前端和后端可能语言逻辑完全不一样，你对此怎么看？ 这可能要花很长时间，要是能取代 Javascript 那就简直了。现在 Dart 在网页开发上做的不错。我个人看好 asm.js 和 WebAssembly，它们都是通过 LLVM 编译的，跟 Swift 一样。如果这两个今后做得足够好，也许就没 Swift 什么事了。未来之事，都很难说。 而且我现在发现，Javascript 已经变成一门基础语言了。我看很多脚本语言现在都直接编译成 Javascript，Javascript 就像比特一样成为一个最基本的表达方式。我觉得五年之后，很有可能 asm.js 会一统网页端。虽然大家说 Javascript 不好 debug，但其实就算你写 C 这么成熟的语言，debug 起来依然很头疼。这也是我们为什么不在 Swift 中加入宏定义，因为那个给编译和 debug 增加了难度。 Swift 语言设计20. Swift 好像一开始就设计得简单易懂、而同时又有很多高阶的复杂操作。经验丰富的程序员可以写出漂亮的语法糖，对编程一窍不通的小孩也可以玩转 Playground。你认为 Swift 是一门将复杂和简易融为一体的语言吗？ Swift 在这点上目前做得还不错。但我担心开源之后大量的新功能添加进来，使得 Swift 不再简单。我一直致力于让 Swift 成为一门简单易学的语言，同时又足够强大。你想我们为什么不支持内联汇编 (inline assembly support) 这样的功能，就是只有极少数极客会喜欢。以后我们也要秉持这个原则。 一个不会写 Swift 的人。打开 Playground，敲下 “print(“Hello World”)”，旁边就会显示出来，这点跟 python 很像，你不用去打”\\n”这样的换行符号。也就是说 Swift 对于新手来说非常友好，我们可以从 Hello World 开始逐步深入，从简单慢慢过渡到复杂。 对于系统开发而言，Swift 相比 Rust，会更好的自动控制内存分配，因为我们可以借鉴开发 ARC 时的经验。你想内存分配这种底层的东西，也只有少数大牛能精通。那为什么不把 ARC 引入到底层来简化开发呢？我觉得这是 Swift 开发的另一个方向。 21. 有人说 Swift 是大杂烩，一部分借鉴 C#，一部分借鉴 Javascript，一部分借鉴 Objective-C，你是怎么看的？ Swift 确实是大杂烩。但是它并不是简单的模仿其他语言，而是借鉴，然后创造出一个伟大的语言。我们确实参考了大量其他的语言设计。比如 Haskell 很多概念就被引入到 Swift 中。Swift 中的 Protocol，就是从 Haskell 的 construct 中得到启发的。 还有其他部分长得像 Dart，亦或是借鉴了 Go 和 C#。这样做也有另一个好处，开发者拿到 Swift 的时候会有种似曾相识的感觉，这样大家也更愿意用 Swift 开发。 Swift vs. Objective-C 22. 给我个现在就学习 Swift 的理由？ 这个其实无所谓。我个人不觉得 Objective-C 会短期内被取代，苹果依然支持 C 和 C++，而且放弃 Objective-C 对苹果来说有百害而无一利。你不必一定要学习 Swift，Swift 只是一门更好的语言。 说到 Swift，我们给它取这个名字就意味着我们希望这门语言非常得高效。它本身设计的目的不是让你短时间内写大量代码，而是用最少的时间、最简洁的代码来完成工作。 编程其实包括方方面面，不仅仅是写代码，还有 debug，给各种系统适配，以及其他各种事情。其实开发的时间短，找 bug 的时间一般都会很长。比如在 Objective-C 中，你会花不少时间修 unrecognized-selector error，但是 Swift 从顶层设计中就排除了这类 bug。 Swift 还有其他一些好处。比如可以对字符串使用 switch…case…语句；可以使用 functional programming；可以用 enum 和 protocol。Swift 其实是一门包罗万象的语言，菜鸟和老手写出来的 Swift 可以完全不一样，这取决于经验。 我最近发现，很多 iOS 开发者会把 Swift 当 Objective-C 来写，逻辑结构完全一样，只是换个语法。其实这就意味着他们没有意识到 Swift 的价值 – 认为 Swift 不过是 Objective-C 的替代品。当开发者深究 Swift 的语法后，他们才会意识到这是一门多么高效的语言。 23. 会不会像 Objective-C 一样，在未来 Swift 添加一些动态特性？ Swift 目前没有加入动态特性的计划。很多人问为什么 Swift 不能有响应，reflection这些特性。甚至有人写博客说，“迟早有一天，苹果要重写 Swift 的所有架构”，我每次在 WWDC 前看到这些博客都会呵呵。很多人不明白什么叫动态性，也不关心我们发布的 Swift 计划表，只是不停的写博客，预测这个吐槽那个。 我个人可以明确表示，Swift 近期内没有加入动态特性的计划。凡事有轻重缓急，我们得先处理其他事情，比如并发模型，比如在系统端上的优化，比如脚本的适配。不过以后如果有时间，Swift 会加入动态特性的，前提是我们计划表里的事情都做完了。 24. 你不担心没有动态特性，很多 Objective-C 的程序员会各种不适应 Swift，然后就放弃用 Swift 了吗？ 我不担心啊。Swift 本身支持 Objective-C 上的所有特性，你只需要那部分代码使用 Objective-C 兼容，然后把它们加入到 runtime 中即可。 虽然有很多人说，我就是想写纯粹的 Swift 代码，但其实我不觉得这是一种倒退。你可以使用 reflection 模型，要用这个功能你用就是了，自己设计的代码结构自己负责。在写代码这事上，从来没有非黑即白一说，我们要做最重要的事，而不是天天在推特上开听证会。Swift 核心组做的工作就是把关 Swift 开发，把这门语言导向一个正确的方向。 Swift 编程规范25. Swift 现在好多语法糖。怎样避免写出奇怪和低效的 Swift 代码？你觉得现在 Swift 可以称得上成熟吗？ 现在正是 Swift 成熟之时。Swift 1 和 Swift 2 的时候，确实语言的变化很大，大家很头疼。但是 Swift 3.0 是一个稳定成熟的版本，它真的不错。之后的工作是在 Swift 3.0 的基础上增加新的函数库或者功能，而不是修改现有的架构。 其实 Swift 开发者也在纠结语法糖太多的问题。我听说一些人出了一些 Swift 的书籍，这很好。其实我们在设计 Swift 的时候，就考虑到语法糖的问题了。比如你写代码，把所有变量都用 var，这时候编译器会提醒你对常量使用 let。这说明一点，Swift 是鼓励 immutable 数据类型的，并且 Xcode 也会自动督促你写出更规范的代码。不过目前对于“是该用 class 还是 struct？”这类比较困难的问题，编译器还没智能到能自动检测并纠正。 26. 有些语言一开始就有设定好的语法糖和规范。为什么 Swift 没有这样，而是让开源社区去讨论？你个人对 Swift 有没有一些编程规范？ 作为一个程序员，我骨子里流淌着编程规范的血液。但在 Swift 的开发过程中，我还是改变了一些固有观念。比如说，我认为所有代码代码段都应该是一个地方输入，一个地方输出。但我后来发现这样设计语言很难维护，可读性也不佳。 比如说我们设计的 guard else 语句，你一定要在末尾写上 return 之类的结束语。这就导致了一个函数有多个地方输出：你在 guard else 里 return，在其他地方也 return，不符合我原来的设想。但是如此设计会令安全性提高，因为我们把一些特殊情况给提前处理掉了。 对于空格这种格式问题，我个人倾向于空 2 格。我知道有些人喜欢空 4 格，还有人喜欢 3 格（因为他们觉得文件中不应该有 tab）。这完全是萝卜青菜各有所爱，大家对此争论不休，哪一种都有一定道理。所以我们最后也没有对 Swift 提出固定的格式要求，大家写出自己喜欢的代码就行。但是这也造成了一定程度的混乱 – 你写的代码格式会与同事的完全不同。但是我觉得这并不会影响语言的多样性。 Go 当年强行推广了一套编程规范，结果到现在仍有争议。我们现在的工作不是做语法上面的规范，而且我们也不希望推出一套规范后大家好不买账。开源的另一个好处是，大家可以自行决定什么是好的语法规范。就算有时间我个人或者 Apple 也不会去写 Swift Style Guide。比起规范我更愿意去回答理论和语言设计上的问题。 有一件趣事我想分享，我一直担心别人会问，为什么 Swift 的函数名叫 func？而不叫 function 或者 fn？这其实颇有争议。不过现在已经是 Swift 3.0 时代了，大家这样用得很顺，我们也不会去更改了，所以争论于此没有意义。 RxSwift 以及响应式编程27.很多开发者用 RxSwift 或者其他响应式编程。你在开发 Swift 过程中有没有仔细研究过响应式编程这些？ 我已经开始关注 RxSwift 了。但是我自己没用响应式编程来开发过产品，所以我对它们的理解来自于博客。RxSwift 看起来很棒，你可以少写很多代码，而且似乎开发效率也会更高。但听说维护和测试起来也很难，有优点也有缺点。 如果我有空写一个 App 的话，我肯定回去试试 RxSwift，然后再过来发表观点。我现在不敢说”强烈推荐”，或者“强烈不推荐”之类的话。 Garbage Collection vs. ARC28. 我们都知道 Garbage Collection 和 ARC 各有千秋。Objective-C 有 Garbage Collection，后来加入了 ARC 的机制。Swift 则是完全 ARC。你能说说为什么你们那么看好 ARC 吗？ Objective-C 最开始是基于 Libauto 系统开发的，而 Libauto 本身就有诸多限制，所以我们当时采用了 Garbage Collection。我个人觉得 ARC 完全要优于 Garbage Collection，因为后者经常在内存上回收一下我们不想回收的变量。所以我们在 Objective-C 上采用了引用计数和 ARC。 ARC 最重要的一个优势就是，它很好的处理了 final 这类参数。如果你用 Garbage Collection，比如 java 吧，final 参数就是那些不被回收一直在跑的东西，这样展开讲问题是一箩筐。我举个最简单的例子，当有个 final 变量运行在一个错误的线程上时，它会多次重跑，导致实例被不停的创建。ARC 则是从根本上解决了这个问题。 目前反对 ARC 的理由主要有两个，一是人们觉得 ARC 引入了额外的开销，因为你要维护引用计数嘛。另一个是 ARC 容易造成循环引用。 我个人要强调的是，这些毛病 Garbage Collection 也有。除此之外 Garbage Collection 还不能终止所有的线程，或者在特定的一个时间点终止一个线程。这是因为 Garbage Collection 引入了安全指针（safepoint），这同样也是一笔额外的开销。 ARC 中引用计数的开销在实际开发中影响不大。而且我们对对象的整个生命流程都有掌控，而这是 Garbage Collection 不具备的。实际上我觉得 ARC 中有些额外开销是必须的，那些不必须的开销以后也会慢慢改进的。 至于循环引用的问题。相比于你必须在具体的一行说明，retain/malloc 这个变量，然后再在后面某一行说明，release/free这个变量这种麻烦事，你只需要用 strong 或者 weak 表示你对对象的所有权，你省去了大量思考内存分配的担忧和操作，这难道不是一个巨大的进步吗？ 身后之事 29.把 Swift 交给 Ted 你放心吗？ 完全不用担心。 Ted 这人实力非常强。斯坦佛的博士生毕业，苹果十年工作经验，曾经以一己之力完成了 Clang 的静态分析器。Ted 在管理方面也很优秀。我有时候会突发奇想，让手下一个人或者一个组去做“我认为有意义”的项目。Ted 则是非常稳健的管理者，他总会领导组员去做最重要的事情，这就是我跟他的不同。 另外我们的小组也很强，核心团队的几个人：Doug Gregor, John McCall, Joe Groff, Dave Abrahams。这几个人都是极其优秀的极客。Swift 其他团队的工程师也很给力。有他们在，没有任何理由 Swift 不会成功。 30. 你为什么去做电动车？ 首先我个人非常喜欢车。但我又懒得自己老是去加油啊、开车，我更喜欢一种更可靠的方式，最好我自己啥也不用做，车子就可以把我送到目的地。我也不需要担心维护啊什么的。我其实是特斯拉最早的一批客户，我觉得特斯拉驾驶起来很开心。 不过我重来没想过我会去一家汽车公司任职，因为我觉得我是个程序员，这跟汽车有啥关系？不过特斯拉让我去做自动驾驶系统，这个就很对我胃口了。因为这也是世界级的难题，我想尝试挑战一下。 补充Chris Lattner 提到的语言 Go 主页：http://golang.org/ Google发布的开源语言。编译速度媲美 C，安全性有过之而无不及。学习曲线也与 Java 类似，比较简单。目前主要用于网络服务器，存储系统，和数据库中。 Dart 主页：https://www.dartlang.org/ Google 开发的语言。基于类，只能单一继承，风格上偏向 C。目标在于成为下一代网络开发语言。目前 Google 正在尝试用 Dart 开发 Android 应用，达到去 java 化的目标。 Haskell 主页：https://www.haskell.org/ 函数式编程语言，支持惰性求值、模式匹配、列表内包、类型类和类型多态。用户很少，普遍认为难学难用。主要用于金融系统及安全性和性能要求抛高的产品。 参考链接 Swift 3 将不包含稳定的ABI 转载 为什么业界很少使用 Haskell？","categories":[{"name":"Swift","slug":"Swift","permalink":"http://www.calm1993.com/categories/Swift/"}],"tags":[{"name":"Swift","slug":"Swift","permalink":"http://www.calm1993.com/tags/Swift/"}]},{"title":"大神技术博客","slug":"大神技术博客","date":"2017-08-08T09:39:26.000Z","updated":"2018-04-11T10:20:06.000Z","comments":true,"path":"post/大神技术博客.html","link":"","permalink":"http://www.calm1993.com/post/大神技术博客.html","excerpt":"","text":"摘要 推荐一些我个人认为非常经典，值得关注的博客。 OneV’s Den SwiftGG 大家尊称为喵神 @onevcat 的博客。对 Swift 技术在国内的推广做了很大的贡献。 Limboy’s HQ 李忠关于 RAC 、组件化的文章流传很广。博客中对架构、编程的思考都很精髓。听说现在转管理后不太更新技术文了。 Casa Taloyum Casa 对架构有很深的理解，《iOS 应用架构谈》系列文章影响深远。 bang’s blog JSPatch 作者 bang 的博客。稳定更新，每篇文章质量都很高。 Garan no dou | ibireme | 一只魔法师的工坊 YYKit 作者的博客，很多文章如《iOS 保持界面流畅的技巧》《深入理解RunLoop》等都有极高的实用价值。 Draveness’s Blog 被人称为灯塔的 Draveness 的博客。Draveness 涉猎很广，文章也很有深度，一半以上的文章我连标题都看不懂。 Halfrost-Field 人称“霜神”冰霜的博客，冰霜的文章针对某个问题总是能有深入、全面的剖析。 星光社 滴滴技术专家戴铭的博客，每篇都是精品。 玉令天下 腾讯杨萧玉的博客，底层细节能深入到汇编的实现，令人惊叹。 MrPeak杂货铺 Peak 以一系列 TCP/IP 相关的文章让人折服，之前博客更新频率很高，多有涉猎。17 年底去 facebook 赚奶粉钱后更新频率有所下降，望早日回归。 Bestswifter @bestswifter 张星宇的博客，《让 BAT 的 offer 不再难拿》介绍了他在大学时准备面试最后进入百度的经历，这篇文章也引起了不小的积极反响。博客除了如 《深入理解 iOS 开发中的锁》 iOS 开发也有不少工程化话题的文章。 故胤道长 顶级 iOS 开发者，曾就职于 Uber，现就职于美帝亚马逊。文风流畅，博客也会谈到不少中美编程文化的差异。 iOS程序犭袁 CYLTabBarController 作者，博客也是篇篇经典。 sunnyxx 滴滴技术专家孙源的博客，对于 OC 语言特性有深入研究。不过整个 17 年没有更新博客。 雷纯锋的技术博客 有多篇经典的博客，如《谈谈 iOS 中图片的解压缩》、《MVVM With ReactiveCocoa》。不过 17 年只更新了一篇文章。 瓜地 冬瓜的博客，作为曾经 acm‘er 的素质与修养，博客总是能够深入底层。 Joy_xx 被人称为架构 joy 的博客，有不少关于 APM 的好文。 唐巧 《iOS 开发如何提高》 JKnight J_Knight的文章总是清晰易懂，更新的也很勤快。 kittenyang philon 天猫技术-苹果核 微读书团队 人人都是产品经理 以产品经理、互联网运营为核心的学习、交流网站 微博：@没故事的卓同学 掘金博客","categories":[],"tags":[{"name":"大神技术博客","slug":"大神技术博客","permalink":"http://www.calm1993.com/tags/大神技术博客/"}]},{"title":"cocoapods出现linker command failed with exit code 1 (use -v to see invocation) 解决方法","slug":"Cocoapods/cocoapods出错","date":"2017-08-08T07:15:07.000Z","updated":"2017-08-09T04:52:30.000Z","comments":true,"path":"post/Cocoapods/cocoapods出错.html","link":"","permalink":"http://www.calm1993.com/post/Cocoapods/cocoapods出错.html","excerpt":"摘要 最近要把项目里的以前手动拖进去的第三方改为cocoapods管理 出现了一个编译问题","text":"摘要 最近要把项目里的以前手动拖进去的第三方改为cocoapods管理 出现了一个编译问题 把原来的拖进去的库删了也会出现linker command failed with exit code 1 (use -v to see invocation) 此时你用cocoapods导入库的时候命令行会有 解决方法第一步去xcode设置 第二步","categories":[{"name":"Cocoapods","slug":"Cocoapods","permalink":"http://www.calm1993.com/categories/Cocoapods/"}],"tags":[{"name":"Cocoapods","slug":"Cocoapods","permalink":"http://www.calm1993.com/tags/Cocoapods/"}]},{"title":"Hexo添加音乐","slug":"Hexo/Hexo添加音乐","date":"2017-08-08T02:56:13.000Z","updated":"2019-08-02T08:47:24.000Z","comments":true,"path":"post/Hexo/Hexo添加音乐.html","link":"","permalink":"http://www.calm1993.com/post/Hexo/Hexo添加音乐.html","excerpt":"摘要 在hexo文章添加网易音乐插件 生成音乐链接打开网易云音乐,搜索想要的音乐,点击生成外部链接播放器","text":"摘要 在hexo文章添加网易音乐插件 生成音乐链接打开网易云音乐,搜索想要的音乐,点击生成外部链接播放器 获取html代码 &lt;iframe frameborder=\"no\" border=\"0\" marginwidth=\"0\" marginheight=\"0\" width=330 height=86 src=\"//music.163.com/outchain/player?type=2&amp;id=436514312&amp;auto=1&amp;height=66\"&gt;&lt;/iframe&gt; 添加在文章中这里是音乐播放器 结尾 带上耳机欣赏一首我最喜欢的 《云烟成雨》","categories":[{"name":"Hexo","slug":"Hexo","permalink":"http://www.calm1993.com/categories/Hexo/"}],"tags":[{"name":"Hexo","slug":"Hexo","permalink":"http://www.calm1993.com/tags/Hexo/"}]},{"title":"NexT主题添加ShareSDK的分享","slug":"Hexo/NexT主题添加ShareSDK的分享","date":"2017-08-07T10:08:15.000Z","updated":"2017-08-09T04:52:20.000Z","comments":true,"path":"post/Hexo/NexT主题添加ShareSDK的分享.html","link":"","permalink":"http://www.calm1993.com/post/Hexo/NexT主题添加ShareSDK的分享.html","excerpt":"原文地址: http://blog.magicer.xyz/2016/04/add-sharesdk/ 今天发现一个分享的的sdk,可以在各个平台使用。由于不太喜欢主题提供的几个分享的样式。就试了试怎么这个。发现还是不错滴。。下面是分享的按钮和分享的样式： 效果见下面—-传送门：ShareSDK Web集成官方文档","text":"原文地址: http://blog.magicer.xyz/2016/04/add-sharesdk/ 今天发现一个分享的的sdk,可以在各个平台使用。由于不太喜欢主题提供的几个分享的样式。就试了试怎么这个。发现还是不错滴。。下面是分享的按钮和分享的样式： 效果见下面—-传送门：ShareSDK Web集成官方文档下面是在网页上分享按钮的代码，只需要将以下代码添加到想要显示的位置即可。appkey是你自己的appkey。&lt;!--MOB SHARE BEGIN--&gt;&lt;div class=\"-mob-share-ui-button -mob-share-open\"&gt;分享&lt;/div&gt;&lt;div class=\"-mob-share-ui\" style=\"display: none\"&gt; &lt;ul class=\"-mob-share-list\"&gt; &lt;li class=\"-mob-share-qzone\"&gt;&lt;p&gt;QQ空间&lt;/p&gt;&lt;/li&gt; &lt;li class=\"-mob-share-qq\"&gt;&lt;p&gt;QQ好友&lt;/p&gt;&lt;/li&gt; &lt;li class=\"-mob-share-weixin\"&gt;&lt;p&gt;微信&lt;/p&gt;&lt;/li&gt; &lt;li class=\"-mob-share-weibo\"&gt;&lt;p&gt;新浪微博&lt;/p&gt;&lt;/li&gt; &lt;li class=\"-mob-share-tencentweibo\"&gt;&lt;p&gt;腾讯微博&lt;/p&gt;&lt;/li&gt; &lt;li class=\"-mob-share-douban\"&gt;&lt;p&gt;豆瓣&lt;/p&gt;&lt;/li&gt; &lt;li class=\"-mob-share-renren\"&gt;&lt;p&gt;人人网&lt;/p&gt;&lt;/li&gt; &lt;li class=\"-mob-share-kaixin\"&gt;&lt;p&gt;开心网&lt;/p&gt;&lt;/li&gt; &lt;li class=\"-mob-share-facebook\"&gt;&lt;p&gt;Facebook&lt;/p&gt;&lt;/li&gt; &lt;li class=\"-mob-share-twitter\"&gt;&lt;p&gt;Twitter&lt;/p&gt;&lt;/li&gt; &lt;li class=\"-mob-share-pocket\"&gt;&lt;p&gt;Pocket&lt;/p&gt;&lt;/li&gt; &lt;li class=\"-mob-share-google\"&gt;&lt;p&gt;Google+&lt;/p&gt;&lt;/li&gt; &lt;li class=\"-mob-share-youdao\"&gt;&lt;p&gt;有道云笔记&lt;/p&gt;&lt;/li&gt; &lt;li class=\"-mob-share-mingdao\"&gt;&lt;p&gt;明道&lt;/p&gt;&lt;/li&gt; &lt;li class=\"-mob-share-pengyou\"&gt;&lt;p&gt;朋友网&lt;/p&gt;&lt;/li&gt; &lt;li class=\"-mob-share-tumblr\"&gt;&lt;p&gt;Tumblr&lt;/p&gt;&lt;/li&gt; &lt;li class=\"-mob-share-instapaper\"&gt;&lt;p&gt;Instapaper&lt;/p&gt;&lt;/li&gt; &lt;li class=\"-mob-share-linkedin\"&gt;&lt;p&gt;LinkedIn&lt;/p&gt;&lt;/li&gt; &lt;/ul&gt; &lt;div class=\"-mob-share-close\"&gt;取消&lt;/div&gt;&lt;/div&gt;&lt;div class=\"-mob-share-ui-bg\"&gt;&lt;/div&gt;&lt;script id=\"-mob-share\" src=\"http://f1.webshare.mob.com/code/mob-share.js?appkey=你的appkey\"&gt;&lt;/script&gt;&lt;!--MOB SHARE END--&gt; 添加到NexT中那么怎么添加到next主题上呢。步骤如下 1.创建文件我们首先要在主题文件夹下的layout文件夹找到_partials下的share文件夹，之后添加一个名为sharesdk.swig的文件。我们可以看出来。这个文件夹下放的全部是分享的配置文件.添加的内容为上面的那一大段代码。只需要修改一部分。修改的部分为：&lt;script id=\"-mob-share\" src=\"http://f1.webshare.mob.com/code/mob-share.js?appkey=&#123;&#123; theme.shareSDKappkey &#125;&#125;\"&gt;&lt;/script&gt; 修改这写的目的是为了让我们能够在主题的配置文件中添加appkey。（只需要在主题的配置文件中添加一个shareSDKappkey并为其附上值即可）。 2添加可选配置虽然我们添加了sharesdk的分享的按钮了，但是如果有一天我们不想使用了呢。当然，很简单。只需要修改配置文件就可以了。那么如何实现呢？ 首先，找到主题文件夹下的layout文件夹下的post.swig 大概在16行左右添加 &lt;div class=&quot;post-spread&quot;&gt; &#123;% if theme.jiathis %&#125; &#123;% include &apos;_partials/share/jiathis.swig&apos; %&#125; &#123;% elseif theme.baidushare %&#125; &#123;% include &apos;_partials/share/baidushare.swig&apos; %&#125; &#123;% elseif theme.add_this_id %&#125; &#123;% include &apos;_partials/share/add-this.swig&apos; %&#125; &#123;% elseif theme.duoshuo_shortname and theme.duoshuo_share %&#125; &#123;% include &apos;_partials/share/duoshuo_share.swig&apos; %&#125; &#123;% elseif theme.sharesdk %&#125; &#123;% include &apos;_partials/share/sharesdk.swig&apos; %&#125; &#123;% endif %&#125;&lt;/div&gt; 添加了代码&#123;% elseif theme.sharesdk %&#125; &#123;% include &apos;_partials/share/sharesdk.swig&apos; %&#125; 这段代码就是根据主题文件的配置，来为文档添加相应的swig文件。要想实现在配置文件中选择性的使用分享功能，只需要在配置文件中修改即可。 修改_config.yml接下来就是修改项目的配置文件了。在主题的配置文件中添加： #Sharesharesdk: trueshareSDKappkey: appkey 这里要说明的是如果没有绑定个人域名分享样式是出不来的,只有用hexo s查看本地才能看到分享远程的是没有的.","categories":[{"name":"Hexo","slug":"Hexo","permalink":"http://www.calm1993.com/categories/Hexo/"}],"tags":[{"name":"Hexo","slug":"Hexo","permalink":"http://www.calm1993.com/tags/Hexo/"}]},{"title":"hexo域名优化网页","slug":"Hexo/hexo域名优化网页","date":"2017-08-07T09:15:47.000Z","updated":"2019-02-18T05:13:00.000Z","comments":true,"path":"post/Hexo/hexo域名优化网页.html","link":"","permalink":"http://www.calm1993.com/post/Hexo/hexo域名优化网页.html","excerpt":"原文地址:Dnspod+Namesilo域名结合实现域名选路解析 摘要 上面的地址采用Dnspod+Namesilo实现国内国外解析,我用的是阿里的万网注册域名阿里云域名注册","text":"原文地址:Dnspod+Namesilo域名结合实现域名选路解析 摘要 上面的地址采用Dnspod+Namesilo实现国内国外解析,我用的是阿里的万网注册域名阿里云域名注册 注册流程阿里有很简单跟着走一遍就可以了,最好能实名认证一下. 域名解析我是直接用的阿里的解析的域名,如果想用DNSPOD解析要改一下解析DNS DNSPOD的把下面的两个解析地址填到图中: f1g1ns1.dnspod.net f1g1ns2.dnspod.net 添加设置记录进入您的域名管理界面，添加别名 留意的部分有： 主机记录：域名主机位（如；如果你的域名是xx.com,主机记录是mm,测mm.xx.com） 记录值：是那个域名的别名（如xx.coding.me，侧mm.xx.com的解析将转向xx.coding.me，即访问mm.xx.com等于访问xx.coding.me） 线路类型：指你的域名是针对哪些线路解析（国内，国外，联通等等，DNSPOD的优势就在这里，选路） 先添加两个github的链接 coding me实现别名在coding添加一个私有博客项目 创建好了后coding.me实现别名,点击Pages 服务->修改域名绑定为你在将要解析到阿里云的别名 gitHub实现别名在Hexo目录下的Source下建立CNAME(注意必须为大写且只允许输入一个别名记录到此文件),并填入你在DNSPOD添加的CNAME到文件CNAME。如何查看是否生效？ 链接到你的Git如：https://github.com/yourname/yourname.github.io -> 点击导航栏部Settings 添加coding me 和github地址解析 添加coding me的SSH公钥 设置站点_config.yml文件设置站点_config.yml是为了每次改变同步都可以同步到github和codingme上的文件deploy: type: git repo: github: git@github.com:fanglinwei/fanglinwei.github.io.git #github地址 codingme: git@git.coding.net:CSummer/CSummer-blog.git #codingme地址 branch: master 设置到这里基本上就可以达到域名访问国内资源了使用codingme绑定的page域名看看,是不是感觉快很多,而使用github绑定的page域名访问会慢一些","categories":[{"name":"Hexo","slug":"Hexo","permalink":"http://www.calm1993.com/categories/Hexo/"}],"tags":[{"name":"Hexo","slug":"Hexo","permalink":"http://www.calm1993.com/tags/Hexo/"}]},{"title":"hexo优化系列","slug":"Hexo/hexo优化系列","date":"2017-08-07T04:53:33.000Z","updated":"2017-09-25T08:53:40.000Z","comments":true,"path":"post/Hexo/hexo优化系列.html","link":"","permalink":"http://www.calm1993.com/post/Hexo/hexo优化系列.html","excerpt":"摘要 这段时间产品上线没啥事做,所以就看了网上的一些博客试着搭建一个自己的Hexo博客.基础搭建就不说了网上百度hexo+github多得是推荐一个基础搭建,格式各样的主题也很多 推荐主题 这里推荐几个好用的 next 我用的就是这个 因为这个是由官方团队维护的后续添加新功能很方便 Yilia 简洁大气！ Yelee 该主题是作者基于Yilia修改而来，改变了大量的样式。 Hexo官网主题推荐","text":"摘要 这段时间产品上线没啥事做,所以就看了网上的一些博客试着搭建一个自己的Hexo博客.基础搭建就不说了网上百度hexo+github多得是推荐一个基础搭建,格式各样的主题也很多 推荐主题 这里推荐几个好用的 next 我用的就是这个 因为这个是由官方团队维护的后续添加新功能很方便 Yilia 简洁大气！ Yelee 该主题是作者基于Yilia修改而来，改变了大量的样式。 Hexo官网主题推荐 优化\b网页速度这里先贴个地址 joryHe优化 这里面写了一大系列的相关优化. 静态文件加载优化. 静态文件就是一些Js,css等文件，通常网站都会调用一大堆这些文件，我们可以合理的将静态资源放到CDN服务器（七牛CDN等），如果你的一些静态资源文件是一些通用的文件，如jquery、fancybox等js或者css，你完全可以使用一些外部免费的开源项目CDN网站，如BootCDN是个很好的选择 ,但是个人觉得在CDN你的静态文件，你应该合理考虑哪些文件才应该进行CDN加速，因为你要CDN加速静态文件的原因是,CDN是以合理的服务器节点返回相关静态资源给你。或许有些情况，你的网站本身的服务器的速度或许比你的CDN更要快速（特别是一些免费的CDN服务）。 外部CDN这是我添加的外部CDN链接 # Script Vendors.# Set a CDN address for the vendor you want to customize.# For example# jquery: https://ajax.googleapis.com/ajax/libs/jquery/2.2.0/jquery.min.js# Be aware that you should use the same version as internal ones to avoid potential problems.# Please use the https protocol of CDN files when you enable https on your site.vendors: # Internal path prefix. Please do not edit it. _internal: lib # Internal version: 2.1.3 jquery: # 以下都是我在bootCDN里引入的 外部CDN链接 可以去http://www.bootcdn.cn 找最新的版本 # Internal version: 2.1.5 # See: http://fancyapps.com/fancybox/ fancybox: fancybox_css: //cdn.bootcss.com/fancybox/3.1.20/jquery.fancybox.css #3.1.20是版本号 # Internal version: 1.0.6 # See: https://github.com/ftlabs/fastclick fastclick: //cdn.bootcss.com/fastclick/1.0.6/fastclick.min.js # Internal version: 1.9.7 # See: https://github.com/tuupola/jquery_lazyload lazyload: //cdn.bootcss.com/jquery_lazyload/1.9.7/jquery.lazyload.min.js # Internal version: 1.2.1 # See: http://VelocityJS.org velocity: //cdn.bootcss.com/velocity/1.5.0/velocity.min.js # Internal version: 1.2.1 # See: http://VelocityJS.org velocity_ui: //cdn.bootcss.com/velocity/1.5.0/velocity.ui.min.js # Internal version: 0.7.9 # See: https://faisalman.github.io/ua-parser-js/ ua_parser: # Internal version: 4.6.2 # See: http://fontawesome.io/ fontawesome: # Internal version: 1 # https://www.algolia.com algolia_instant_js: //cdn.bootcss.com/instantsearch.js/2.1.0-beta.2/instantsearch.min.js algolia_instant_css: //cdn.bootcss.com/instantsearch.js/2.1.0-beta.2/instantsearch.min.css # Internal version: 1.0.2 # See: https://github.com/HubSpot/pace # Or use direct links below: pace: //cdn.bootcss.com/pace/1.0.2/pace.min.js pace_css: //cdn.bootcss.com/pace/1.0.2/themes/blue/pace-theme-flash.min.css 从以上看出，很多Next插件已经可以自定义CDN链接，但是如果存在一些没有在上面列出的呢，也有办法，如果想要了解操作方式，请访问NEXT 加载您自定以的静态文件,如果你还需要进行图片的CDN，点击CDN图片加速，实现图片慢加载,以上都可以实现CDN。这里要注意的是如果要引用自己CDN资源(七牛或者阿里云)最好申请注册个个人域名和博客绑定起来.不然会出问题. 字体引用修改站内引用的字体 实现方法:到主题的_config.yml中设置不从google加载字体（默认会加载本地字体） font: enable: true # Uri of fonts host. E.g. //fonts.googleapis.com (Default) //fonts.css.network host: //fonts.css.network #这里把这里改成 //fonts.css.network 优化到这里你会感觉你的博客网页已经快一些了但是还是会有点慢,那么久\b就要用域名来优化了hexo域名优化网页","categories":[{"name":"Hexo","slug":"Hexo","permalink":"http://www.calm1993.com/categories/Hexo/"}],"tags":[{"name":"Hexo","slug":"Hexo","permalink":"http://www.calm1993.com/tags/Hexo/"}]},{"title":"懒加载","slug":"懒加载","date":"2017-08-01T11:04:38.000Z","updated":"2017-08-09T04:52:16.000Z","comments":true,"path":"post/懒加载.html","link":"","permalink":"http://www.calm1993.com/post/懒加载.html","excerpt":"定义一个懒加载的宏#define DYJ_LAZY(object, assignment) (object = object ?: assignment) 使用- (UINavigationBar *)navBar&#123; return DYJ_LAZY(_navBar, (&#123; UINavigationBar *bar = [[UINavigationBar alloc] init]; bar.barStyle = UINavigationBar.appearance.barStyle; bar.translucent = YES; [self.view addSubview:bar]; [bar setFrame:CGRectMake(0, 0, SCREEN_WIDTH, 64)]; bar; &#125;));&#125;","text":"定义一个懒加载的宏#define DYJ_LAZY(object, assignment) (object = object ?: assignment) 使用- (UINavigationBar *)navBar&#123; return DYJ_LAZY(_navBar, (&#123; UINavigationBar *bar = [[UINavigationBar alloc] init]; bar.barStyle = UINavigationBar.appearance.barStyle; bar.translucent = YES; [self.view addSubview:bar]; [bar setFrame:CGRectMake(0, 0, SCREEN_WIDTH, 64)]; bar; &#125;));&#125;","categories":[{"name":"iOS","slug":"iOS","permalink":"http://www.calm1993.com/categories/iOS/"}],"tags":[{"name":"iOS","slug":"iOS","permalink":"http://www.calm1993.com/tags/iOS/"},{"name":"OC","slug":"OC","permalink":"http://www.calm1993.com/tags/OC/"}]}]}